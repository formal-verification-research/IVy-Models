#lang ivy1.7

type sources = {void,rc1,rc2,rc3} #rc is router chosen

object spec = { 
	
	individual copy_finished : bool
	
	after init {
		copy_finished := false;
		a.r1.hf := true;
		a.r2.hf := true;
		a.r3.hf := true;
		b.r1.hf := true;
		b.r2.hf := true;
		b.r3.hf := true;
		c.r1.hf := true;
		c.r2.hf := true;
		c.r3.hf := true;
		d.r_recv.hf := true;
		e.r_recv.hf := true;
		f.r_recv.hf := true;
		
		d.r1.hf := false;
		d.r2.hf := false;
		d.r3.hf := false;
		e.r1.hf := false;
		e.r2.hf := false;
		e.r3.hf := false;
		f.r1.hf := false;
		f.r2.hf := false;
		f.r3.hf := false;
		a.r_recv.hf := false;
		b.r_recv.hf := false;
		c.r_recv.hf := false;
		call count_flits;
	}
	
	action copy_data = {
		
		if d.r_recv.hf {
			a.r1.hf := true;
			b.r1.hf := true;
			c.r1.hf := true;
		} else {
			a.r1.hf := false;
			b.r1.hf := false;
			c.r1.hf := false;
		};
		if e.r_recv.hf {
			a.r2.hf := true;
			b.r2.hf := true;
			c.r2.hf := true;
		} else {
			a.r2.hf := false;
			b.r2.hf := false;
			c.r2.hf := false;
		};
		if f.r_recv.hf {
			a.r3.hf := true;
			b.r3.hf := true;
			c.r3.hf := true;
		} else {
			a.r3.hf := false;
			b.r3.hf := false;
			c.r3.hf := false;
		};
		
		if a.r_recv.hf {
			d.r1.hf := true;
			e.r1.hf := true;
			f.r1.hf := true;
		} else {
			d.r1.hf := false;
			e.r1.hf := false;
			f.r1.hf := false;
		};
		if b.r_recv.hf {
			d.r2.hf := true;
			e.r2.hf := true;
			f.r2.hf := true;
		} else {
			d.r2.hf := false;
			e.r2.hf := false;
			f.r2.hf := false;
		};
		if c.r_recv.hf {
			d.r3.hf := true;
			e.r3.hf := true;
			f.r3.hf := true;
		} else {
			d.r3.hf := false;
			e.r3.hf := false;
			f.r3.hf := false;
		};
		
		assume ( (a.r_recv.hf & b.r_recv.hf & c.r_recv.hf) & (~d.r_recv.hf & ~e.r_recv.hf & ~f.r_recv.hf) ) |
		       ( (a.r_recv.hf & b.r_recv.hf & d.r_recv.hf) & (~c.r_recv.hf & ~e.r_recv.hf & ~f.r_recv.hf) ) |
		       ( (a.r_recv.hf & b.r_recv.hf & e.r_recv.hf) & (~c.r_recv.hf & ~d.r_recv.hf & ~f.r_recv.hf) ) |
		       ( (a.r_recv.hf & b.r_recv.hf & f.r_recv.hf) & (~c.r_recv.hf & ~d.r_recv.hf & ~e.r_recv.hf) ) |
		       ( (a.r_recv.hf & c.r_recv.hf & d.r_recv.hf) & (~b.r_recv.hf & ~e.r_recv.hf & ~f.r_recv.hf) ) |
		       ( (a.r_recv.hf & c.r_recv.hf & e.r_recv.hf) & (~b.r_recv.hf & ~d.r_recv.hf & ~f.r_recv.hf) ) |
		       ( (a.r_recv.hf & c.r_recv.hf & f.r_recv.hf) & (~b.r_recv.hf & ~d.r_recv.hf & ~e.r_recv.hf) ) |
		       ( (a.r_recv.hf & d.r_recv.hf & e.r_recv.hf) & (~b.r_recv.hf & ~c.r_recv.hf & ~f.r_recv.hf) ) |
		       ( (a.r_recv.hf & d.r_recv.hf & f.r_recv.hf) & (~b.r_recv.hf & ~c.r_recv.hf & ~e.r_recv.hf) ) |
		       ( (a.r_recv.hf & e.r_recv.hf & f.r_recv.hf) & (~b.r_recv.hf & ~c.r_recv.hf & ~d.r_recv.hf) ) |
		       ( (b.r_recv.hf & c.r_recv.hf & d.r_recv.hf) & (~a.r_recv.hf & ~e.r_recv.hf & ~f.r_recv.hf) ) |
		       ( (b.r_recv.hf & c.r_recv.hf & e.r_recv.hf) & (~a.r_recv.hf & ~d.r_recv.hf & ~f.r_recv.hf) ) |
		       ( (b.r_recv.hf & c.r_recv.hf & f.r_recv.hf) & (~a.r_recv.hf & ~e.r_recv.hf & ~d.r_recv.hf) ) |
		       ( (b.r_recv.hf & d.r_recv.hf & e.r_recv.hf) & (~a.r_recv.hf & ~c.r_recv.hf & ~f.r_recv.hf) ) |
		       ( (b.r_recv.hf & d.r_recv.hf & f.r_recv.hf) & (~a.r_recv.hf & ~c.r_recv.hf & ~e.r_recv.hf) ) |
		       ( (b.r_recv.hf & e.r_recv.hf & f.r_recv.hf) & (~a.r_recv.hf & ~c.r_recv.hf & ~d.r_recv.hf) ) |
		       ( (c.r_recv.hf & d.r_recv.hf & e.r_recv.hf) & (~a.r_recv.hf & ~b.r_recv.hf & ~f.r_recv.hf) ) |
		       ( (c.r_recv.hf & d.r_recv.hf & f.r_recv.hf) & (~a.r_recv.hf & ~b.r_recv.hf & ~e.r_recv.hf) ) |
		       ( (c.r_recv.hf & e.r_recv.hf & f.r_recv.hf) & (~a.r_recv.hf & ~b.r_recv.hf & ~d.r_recv.hf) ) |
		       ( (d.r_recv.hf & e.r_recv.hf & f.r_recv.hf) & (~a.r_recv.hf & ~b.r_recv.hf & ~c.r_recv.hf) );
		
		call count_flits;
		copy_finished := true;
		
		
	} #end copy_data
	
	type bitv
	individual flit_count : bitv
	interpret bitv -> bv[3]
	
	action count_flits = {
	
		flit_count := 0;
		
		# if a.r1.hf { flit_count := flit_count + 1; };
		# if a.r2.hf { flit_count := flit_count + 1; };
		# if a.r3.hf { flit_count := flit_count + 1; };
		# if b.r1.hf { flit_count := flit_count + 1; };
		# if b.r2.hf { flit_count := flit_count + 1; };
		# if b.r3.hf { flit_count := flit_count + 1; };
		# if c.r1.hf { flit_count := flit_count + 1; };
		# if c.r2.hf { flit_count := flit_count + 1; };
		# if c.r3.hf { flit_count := flit_count + 1; };
		# if d.r1.hf { flit_count := flit_count + 1; };
		# if d.r2.hf { flit_count := flit_count + 1; };
		# if d.r3.hf { flit_count := flit_count + 1; };
		# if e.r1.hf { flit_count := flit_count + 1; };
		# if e.r2.hf { flit_count := flit_count + 1; };
		# if e.r3.hf { flit_count := flit_count + 1; };
		# if f.r1.hf { flit_count := flit_count + 1; };
		# if f.r2.hf { flit_count := flit_count + 1; };
		# if f.r3.hf { flit_count := flit_count + 1; };
		
		if a.r_recv.hf { flit_count := flit_count + 1; };
		if b.r_recv.hf { flit_count := flit_count + 1; };
		if c.r_recv.hf { flit_count := flit_count + 1; };
		if d.r_recv.hf { flit_count := flit_count + 1; };
		if e.r_recv.hf { flit_count := flit_count + 1; };
		if f.r_recv.hf { flit_count := flit_count + 1; };
		
		ensure flit_count = 3;
		
		# {a,b,c} {a,b,d} {a,b,e} {a,b,f} 
		# {a,c,d} {a,c,e} {a,c,f} 
		# {a,d,e} {a,d,f} 
		# {a,e,f} 
		# {b,c,d} {b,c,e} {b,c,f} 
		# {b,d,e} {b,d,f} 
		# {b,e,f} 
		# {c,d,e} {c,d,f} 
		# {c,e,f} 
		# {d,e,f}
		
	}
	
	#This is the counter that is making things fail right now. See 131.txt
	conjecture copy_finished -> (flit_count = 3) #each router is represented in 4 places, times 3 flits in system
	
	action async = { #the invariant doesn't work when 2 arbiters try to send simultaneously.
		#in example, both A and B arbiters picked r25 but A sent first.
		if a.arbiter.ready {
			b.arbiter.ready := false;
			c.arbiter.ready := false;
		};
		if b.arbiter.ready {
			a.arbiter.ready := false;
			c.arbiter.ready := false;

		};
		if c.arbiter.ready {
			a.arbiter.ready := false;
			b.arbiter.ready := false;

		};
		if d.arbiter.ready {
			e.arbiter.ready := false;
			f.arbiter.ready := false;
		};
		if e.arbiter.ready {
			d.arbiter.ready := false;
			f.arbiter.ready := false;
		};
		if f.arbiter.ready {
			d.arbiter.ready := false;
			e.arbiter.ready := false;
		};
	
	} #end async
	conjecture copy_finished -> (a.r1.hf = b.r1.hf) & (b.r1.hf = c.r1.hf) & (c.r1.hf = d.r_recv.hf)
	conjecture copy_finished -> (a.r2.hf = b.r2.hf) & (b.r2.hf = c.r2.hf) & (c.r2.hf = e.r_recv.hf)
	conjecture copy_finished -> (a.r3.hf = b.r3.hf) & (b.r3.hf = c.r3.hf) & (c.r3.hf = f.r_recv.hf)
	conjecture copy_finished -> (d.r1.hf = e.r1.hf) & (e.r1.hf = f.r1.hf) & (f.r1.hf = a.r_recv.hf)
	conjecture copy_finished -> (d.r2.hf = e.r2.hf) & (e.r2.hf = f.r2.hf) & (f.r2.hf = b.r_recv.hf)
	conjecture copy_finished -> (d.r3.hf = e.r3.hf) & (e.r3.hf = f.r3.hf) & (f.r3.hf = c.r_recv.hf)
	
	conjecture a.r_recv.hf -> (d.r1.hf & e.r1.hf & f.r1.hf)
	conjecture b.r_recv.hf -> (d.r2.hf & e.r2.hf & f.r2.hf)
	conjecture c.r_recv.hf -> (d.r3.hf & e.r3.hf & f.r3.hf)
	conjecture d.r_recv.hf -> (a.r1.hf & b.r1.hf & c.r1.hf)
	conjecture e.r_recv.hf -> (a.r2.hf & b.r2.hf & c.r2.hf)
	conjecture f.r_recv.hf -> (a.r3.hf & b.r3.hf & c.r3.hf)
	
	conjecture (a.r1.hf | b.r1.hf | c.r1.hf) -> (d.r_recv.hf & a.r1.hf & b.r1.hf & c.r1.hf)
	conjecture (a.r2.hf | b.r2.hf | c.r2.hf) -> (e.r_recv.hf & a.r2.hf & b.r2.hf & c.r2.hf)
	conjecture (a.r3.hf | b.r3.hf | c.r3.hf) -> (f.r_recv.hf & a.r3.hf & b.r3.hf & c.r3.hf)
	conjecture (d.r1.hf | e.r1.hf | f.r1.hf) -> (a.r_recv.hf & d.r1.hf & e.r1.hf & f.r1.hf)
	conjecture (d.r2.hf | e.r2.hf | f.r2.hf) -> (b.r_recv.hf & d.r2.hf & e.r2.hf & f.r2.hf)
	conjecture (d.r3.hf | e.r3.hf | f.r3.hf) -> (c.r_recv.hf & d.r3.hf & e.r3.hf & f.r3.hf)

} #end spec

module node = {

	module r_send = {
		
		individual hf : bool 
		
		# after init {
			# hf := *; 
		# }
		
		before send {
			require hf;
			require spec.flit_count = 3;
		}
		
		action send = {
			#assert hf;
			call arbiter.check;
		} #end send
		
		action has_sent = {
			hf := false;
		} #end has_sent
		
		# after has_sent {
			# assert ~hf;
		# }
		
	} #end r_send 
	
	instance r1 : r_send
	instance r2 : r_send
	instance r3 : r_send
	# instance r4 : r_send
	# instance r5 : r_send
	# instance r6 : r_send
	
	object arbiter = {
		
		# individual boolean_rand : bool 
		individual get_from : sources 
		individual ready : bool
		
		after init {
			# boolean_rand := *;
			get_from := void;
			ready := false;
		}
		
		before choose {
			get_from := void;
			ready := false;
		}
		
		action choose = {
			if r1.hf {
				if r2.hf {
					if r3.hf { #if all 3 have flits
						get_from := *; 
						assume get_from = rc1 | get_from = rc2 | get_from = rc3; 
					}
					else { #if only r1 and r2 have flits
						get_from := *; 
						assume get_from = rc1 | get_from = rc2; 
		            };
				}
				else if r3.hf { #if just r1 and r3 have flits
					get_from := *; 
						assume get_from = rc1 | get_from = rc3; 
				}
				else { #if only r1 has a flit
					get_from := rc1;
		        };
	            ready := true;
			}	
			else if r2.hf {
				if r3.hf { #if r2 and r3 have flits
					get_from := *; 
					assume get_from = rc2 | get_from = rc3; 
				}
				else { #if only r2 has a flit
					get_from := rc2;
		        };
                ready := true;
			}
			else if r3.hf { #if only r3 has a flit
				get_from := rc3;
				ready := true;
			}
			else { #false alarm
				get_from := void;
				ready := false;
			};
			call spec.async;
		} #end choose
		
		action check = {
			# if ~r_recv.hf & ready & (get_from = rc4 | get_from = rc5 | get_from = rc6) {
				# assert ready;
				# assert ~r_recv.hf; 
				# assert r4.hf | r5.hf | r6.hf;
				# call send; 
			# }
			# else 
			if ~r_recv.hf & ready & (get_from = rc1 | get_from = rc2 | get_from = rc3) {
				assert ready;
				assert ~r_recv.hf; 
				#assert r1.hf | r2.hf | r3.hf;
				call send; 
			}
			else {
				ready := false;
				get_from := void;
			#	call spec.copy_data;
			};
		} #end check
		
		execute choose before check
		
		action send = {
			ready := false;
			if get_from = rc1 {
				assert r1.hf;
				call r1.has_sent;
				call r_recv.get_flit;
				call a.r_recv.has_sent; 
			};
			if get_from = rc2 {
				assert r2.hf;
				call r2.has_sent;
				call r_recv.get_flit;
				call b.r_recv.has_sent;

			};
			if get_from = rc3 {
				assert r3.hf;
				call r3.has_sent;
				call r_recv.get_flit;
				call c.r_recv.has_sent;
			};
			
			#call spec.has_sent; IDEA IDEA IDEA IDEA IDEA IDEA IDEA IDEA IDEA IDEA IDEA IDEA IDEA
			
			# if get_from = rc4 {
				# assert r4.hf;
				# call r4.has_sent;
				# call r_recv.get_flit;
				# call d.r_recv.has_sent; 
			# };
			# if get_from = rc5 {
				# assert r5.hf;
				# call r5.has_sent;
				# call r_recv.get_flit;
				# call e.r_recv.has_sent; 
			# };
			# if get_from = rc6 {
				# assert r6.hf;
				# call r6.has_sent;
				# call r_recv.get_flit;
				# call f.r_recv.has_sent; 
			# };
			get_from := void;
		} #end send
				
		conjecture (ready & r1.hf) -> get_from ~= void
		conjecture (ready & r2.hf) -> get_from ~= void
		conjecture (ready & r3.hf) -> get_from ~= void
		# conjecture (ready & r4.hf) -> get_from ~= void
		# conjecture (ready & r5.hf) -> get_from ~= void
		# conjecture (ready & r6.hf) -> get_from ~= void
		
		conjecture ready -> get_from ~= void
		
		conjecture ready -> (r1.hf | r2.hf | r3.hf)
		
		# conjecture (ready & r4.hf & ~r5.hf & ~r6.hf) -> get_from = rc4 
		# conjecture (ready & ~r4.hf & r5.hf & ~r6.hf) -> get_from = rc5 
		# conjecture (ready & ~r4.hf & ~r5.hf & r6.hf) -> get_from = rc6
		conjecture (ready & r1.hf & ~r2.hf & ~r3.hf) -> get_from = rc1
		conjecture (ready & ~r1.hf & r2.hf & ~r3.hf) -> get_from = rc2
		conjecture (ready & ~r1.hf & ~r2.hf & r3.hf) -> get_from = rc3
		
		# conjecture (ready & r4.hf & r5.hf & ~r6.hf) -> (get_from = rc4 | get_from = rc5)
        # conjecture (ready & ~r4.hf & r5.hf & r6.hf) -> (get_from = rc5 | get_from = rc6)
		# conjecture (ready & r4.hf & ~r5.hf & r6.hf) -> (get_from = rc4 | get_from = rc6)
		conjecture (ready & r1.hf & r2.hf & ~r3.hf) -> (get_from = rc1 | get_from = rc2)
		conjecture (ready & ~r1.hf & r2.hf & r3.hf) -> (get_from = rc2 | get_from = rc3)
		conjecture (ready & r1.hf & ~r2.hf & r3.hf) -> (get_from = rc1 | get_from = rc3)
		
		conjecture (ready & get_from = rc1) -> (r1.hf)
		conjecture (ready & get_from = rc2) -> (r2.hf)
		conjecture (ready & get_from = rc3) -> (r3.hf)
		# conjecture (ready & get_from = rc4) -> (r4.hf)
		# conjecture (ready & get_from = rc5) -> (r5.hf)
		# conjecture (ready & get_from = rc6) -> (r6.hf)
		
	} #end arbiter
	
	object r_recv = {
		
		individual hf : bool #whether or not there is a flit here
		
		# after init {
			# hf := false; #start without a flit
			# assert ~hf; #make sure it knows there is no flit
		# }
		
		before get_flit {
			require ~hf; #make sure there is no flit here before getting one
		}
		
		action get_flit = {
			hf := true; #get the flit
		} #end get_flit
		
		# after get_flit {
			# assert hf; #make sure it got the flit
		# }
		
		action has_sent = {
			#hf := false;
			call spec.copy_data;
		} #end has_sent
		
	} #end r_recv

	export r1.send
	export r2.send
	export r3.send
	# export r4.send
	# export r5.send
	# export r6.send
	
	invariant ~(arbiter.ready & arbiter.get_from = void)

	
} #end top_row

instance a : node
instance b : node
instance c : node
instance d : node
instance e : node
instance f : node
