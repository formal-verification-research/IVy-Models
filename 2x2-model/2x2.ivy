#lang ivy1.7


####################
#                  #
#    VARIABLES     #
#                  #
####################


type int
interpret int -> int
type arbiter = {an10,aw10,as11,ae00,an00,aw11,ape10} #list of arbiters (no underscores to differentiate)
type router = {rn10,rw10,rs11,re00,rpe10} #list of routers (no underscores to differentiate)
type coord = {0,1} #simple 0s and 1s the destination can be set to

relation sending(S:router,R:router,A:arbiter) #a link between an arbiter and the routers sending and receiving the packet





####################
#                  #
#    INTERFACE     #
#                  #
####################



object intf = { 
	action change_watch
	action check(s:router,r:router,a:arbiter) #arbiter checks routers to see if they have packets - not super accurate, but the best I could come up with so far
	action choose(s:router,r:router,a:arbiter) #if simultaneous requests, choose which to get
	action send(s:router,r:router,a:arbiter) = {#once the router order is chosen, get flits from those routers and send to the next router
		sending(s,r,a) := true;
		sending(s,r,a) := false;
	}
}


object spec = { #The specifications for actions to run

	var flit_to_watch : int

    after init { #on startup, nothing is faulty
       	arb_N_10.faulty := false;
		arb_W_10.faulty := false;
		arb_S_11.faulty := false;
		arb_E_00.faulty := true; 
		flit_to_watch := *;
	}
	
	before intf.change_watch {
		flit_to_watch := *;
	}
	
	before intf.check {
		require r_PE_10.has_flit | r_W_10.has_flit | r_E_00.has_flit | r_N_10.has_flit | r_S_11.has_flit;
		#require that at least someone has a flit before it can be sent to an arbiter
	}
	
	before intf.choose {
		require (r_PE_10.has_flit & r_W_10.has_flit) | (r_N_10.has_flit & r_W_10.has_flit) | (r_PE_10.has_flit & r_N_10.has_flit);
		#require that two routers have flits to send to the same arbiter in order to choose one to serve
		#eventually I'll add logic to check the destination as well
	}
	
	before intf.send {
		#eventually require something clever
	}
	
} 



#############################
#                           #
# r_PE_10 GENERATES PACKETS #
#                           #
#############################

object r_PE_10 = { 
	
	individual has_flit : bool #whether or not there exists a flit
	individual ready : bool
	
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	
	individual last_generated : int
	individual id : int #the ID of the flit that is currently here
	
	after init {
		has_flit := *; #maybe it has a flit, maybe it doesn't
		ready := false; #it's not ready to send the flit quite yet.
		last_generated := 1;
	}
	
	action generate(a:arbiter,r:router) = { #choosing the destination
		
		if has_flit {
			x_dest := *; #arbitrarily chooses
	        y_dest := *; #arbitrarily chooses
			id := last_generated + 1;
			ensure id > last_generated;
			last_generated := id;
	        if x_dest = 1 & y_dest = 1 { #only if it's going directly north
				if arb_N_10.faulty & ~arb_W_10.faulty & ~arb_W_10.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
					assigned := aw10; #send it to the other arbiter if an10 is blocked.	
					ready := true; #mark that it's ready to receive a packet
				}
				else if arb_N_10.busy { #if the receiver is busy, 
					has_flit := false; #drop the flit to prevent deadlock
					ready := false;
				}
				else { #if it's going north and everything's clear
					require ~arb_N_10.faulty & ~arb_N_10.busy; #double check that it's clear
					assigned := an10; #send north if it needs to go to (1,1)
					ready := true;
				}
			}
	        else { #same as 110-123 but for packets not going to (1,1).
				if arb_W_10.faulty & ~arb_N_10.faulty & ~arb_N_10.busy {
					assigned := an10; #send it to the other arbiter if aw10 is blocked.
					ready := true;
				}
				else if arb_W_10.busy {
					has_flit := false;
					ready := false;
				}
				else {
					require ~arb_W_10.faulty & ~arb_N_10.busy;
					assigned := aw10; #if it's not going to (1,1), send it west by default.
					ready := true;
				}
			}
		}
		
    }
	
	action send_flit(s:router,r:router,a:arbiter) = {
		require has_flit & ready;
		call intf.check(s,r,a);
	}

   
} export r_PE_10.generate
export r_PE_10.send_flit








####################
#                  #
# ALL THE ARBITERS #
#                  #
####################

# The arbiters only check which arbiter is assigned, not the eventual destination.

object arb_N_10 = {

	individual faulty : bool
	individual busy : bool
	
	type can_get_from = {r_pe_10,r_w_10,r_n_10,void} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { #before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
		require ~busy & ((r_PE_10.has_flit & r_PE_10.assigned = an10) | (r_W_10.has_flit & r_W_10.assigned = an10) | (r_N_10.has_flit & r_N_10.assigned = an10)); 
		rand := *; #arbitrarily choose either a true or a false.
	}
		
	before move_flit(s:router,r:router,a:arbiter) { #check for simultaneous requests
		if r_PE_10.has_flit & r_PE_10.assigned = an10 {
			if r_W_10.has_flit & r_W_10.assigned = an10 {
				if r_N_10.has_flit & r_N_10.assigned = an10 {
					get_from := *;
				}
				else {
					if rand {
						get_from := r_pe_10;
					}
					else {
						get_from := r_w_10;
					}
				}
			}
			else {
				get_from := r_pe_10;
			}
		}	
		else if r_W_10.has_flit & r_W_10.assigned = an10 {
			if r_N_10.has_flit & r_N_10.assigned = an10 {
				if rand {
					get_from := r_w_10;
				}
				else {
					get_from := r_n_10;
				}
			}
			else {
				get_from := r_w_10;
			}
		}
		else if r_N_10.has_flit & r_N_10.assigned = an10 {
			get_from := r_n_10;
		}
	}
	
	action move_flit(s:router,r:router,a:arbiter) = { 
		call intf.send(s,r,a); #modify the sending relation
		if get_from = r_pe_10 {
			r_PE_10.has_flit := false; #copy over the packet and all its information
			r_S_11.x_dest := r_PE_10.x_dest;
			r_S_11.y_dest := r_PE_10.y_dest;
			r_S_11.id := r_PE_10.id;
			r_S_11.has_flit := true;
		}
		else if get_from = r_w_10 {
			r_W_10.has_flit := false;
			r_S_11.x_dest := r_W_10.x_dest;
			r_S_11.y_dest := r_W_10.y_dest;
			r_S_11.id := r_W_10.id;
			r_S_11.has_flit := true;
		}
		else if get_from = r_n_10 {
			r_N_10.has_flit := false;
			r_S_11.x_dest := r_N_10.x_dest;
			r_S_11.y_dest := r_N_10.y_dest;
			r_S_11.id := r_N_10.id;
			r_S_11.has_flit := true;
		}
	}
} export arb_N_10.move_flit



object arb_W_10 = {
	
	individual faulty : bool
	individual busy : bool
	
	type can_get_from = {r_pe_10,r_w_10,r_n_10} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { 							#before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
		require ~busy & ((r_PE_10.has_flit & r_PE_10.assigned = aw10) | (r_W_10.has_flit & r_W_10.assigned = aw10) | (r_N_10.has_flit & r_N_10.assigned = aw10)); 
	}
	
	before move_flit(s:router,r:router,a:arbiter) { #check for simultaneous requests
		if r_PE_10.has_flit & r_PE_10.assigned = aw10 {
			if r_W_10.has_flit & r_W_10.assigned = aw10 {
				if r_N_10.has_flit & r_N_10.assigned = aw10 {
					get_from := *;
				}
				else {
					if rand {
						get_from := r_pe_10;
					}
					else {
						get_from := r_w_10;
					}
				}
			}
			else {
				get_from := r_pe_10;
			}
		}	
		else if r_W_10.has_flit & r_W_10.assigned = aw10 {
			if r_N_10.has_flit & r_N_10.assigned = aw10 {
				if rand {
					get_from := r_w_10;
				}
				else {
					get_from := r_n_10;
				}
			}
			else {
				get_from := r_w_10;
			}
		}
		else if r_N_10.has_flit & r_N_10.assigned = aw10 {
			get_from := r_n_10;
		}
		
	}
	
	action move_flit(s:router,r:router,a:arbiter) = { 
		call intf.send(s,r,a); #modify the sending relation
		if get_from = r_pe_10 { #send the packet and all its information
			r_PE_10.has_flit := false;
			r_E_00.x_dest := r_PE_10.x_dest;
			r_E_00.y_dest := r_PE_10.y_dest;
			r_E_00.id := r_PE_10.id;
			r_E_00.has_flit := true;
		}
		else if get_from = r_w_10 {
			r_W_10.has_flit := false;
			r_E_00.x_dest := r_W_10.x_dest;
			r_E_00.y_dest := r_W_10.y_dest;
			r_E_00.id := r_W_10.id;
			r_E_00.has_flit := true;
		}
		else if get_from = r_n_10 {
			r_N_10.has_flit := false;
			r_E_00.x_dest := r_N_10.x_dest;
			r_E_00.y_dest := r_N_10.y_dest;
			r_E_00.id := r_N_10.id;
			r_E_00.has_flit := true;
		}
		
	}
} export arb_W_10.move_flit





object arb_PE_10 = {
	
	individual busy : bool
	
	type can_get_from = {r_w_10,r_n_10} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	
	after init { 							#before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
		require ~busy & ((r_W_10.has_flit & r_W_10.assigned = ape10) | (r_N_10.has_flit & r_N_10.assigned = ape10)); 
	}
	
	before move_flit(s:router,r:router,a:arbiter) { #check for simultaneous requests
		if r_N_10.has_flit & r_N_10.assigned = ape10 {
			if r_W_10.has_flit & r_W_10.assigned = ape10 {
				get_from := *;
			}
			else {
				get_from := r_n_10;
			}
		}
		else if r_W_10.has_flit & r_W_10.assigned = ape10 {
			get_from := r_w_10;
		}
		
	}
	
	action move_flit(s:router,r:router,a:arbiter) = { 
		call intf.send(s,r,a); #modify the sending relation
		if get_from = r_w_10 {
			r_W_10.has_flit := false;
		}
		else if get_from = r_n_10 {
			r_N_10.has_flit := false;
		}
	}
} export arb_PE_10.move_flit







####################
#                  #
# ALL THE ROUTERS  #
#                  #
####################

object r_W_10 = {
	individual has_flit : bool
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	individual ready : bool
	individual id : int #the ID of the flit that is currently here
	individual tally : int
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		tally := 0;
		if has_flit {
			arb_E_00.busy := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
			id := 0; #don't give it an individual ID if it was in the system to begin with.
		}
	}
	
	action assigner = { #check the destination to determine which arbiter to assign.
		require has_flit;
		if x_dest = 1 & y_dest = 0 {
			assigned := ape10;
			ready := true;	
		} 
		else if x_dest = 1 & y_dest = 1 { #only if it's going directly north
			if arb_N_10.faulty & ~arb_W_10.faulty & ~arb_W_10.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
				assigned := aw10; #send it to the other arbiter if an10 is blocked.	
				ready := true; #mark that it's ready to receive a packet
			}
			else if arb_N_10.busy { #if the receiver is busy, 
				has_flit := false; #drop the flit to prevent deadlock
				ready := false;
			}
			else { #if it's going north and everything's clear
				require ~arb_N_10.faulty & ~arb_N_10.busy; #double check that it's clear
				assigned := an10; #send north if it needs to go to (1,1)
				ready := true;
			}
		}
		else { #same as 110-123 but for packets not going to (1,1).
			if arb_W_10.faulty & ~arb_N_10.faulty & ~arb_N_10.busy {
				assigned := an10; #send it to the other arbiter if aw10 is blocked.
				ready := true;
			}
			else if arb_W_10.busy {
				has_flit := false;
				ready := false;
			}
			else {
				require ~arb_W_10.faulty & ~arb_N_10.busy;
				assigned := aw10; #if it's not going to (1,1), send it west by default.
				ready := true;
			}
		}	
	}
	
	action counter = {
		require has_flit & (id = spec.flit_to_watch); #only proceed if it has a flit and the ID is the assigned ID to watch
		tally := tally + 1;
		if tally > 5 {
			has_flit := false;
			call intf.change_watch;
		}
	}
	
	execute counter before assigner
	
} export r_W_10.assigner
  export r_W_10.counter



object r_N_10 = {
	individual has_flit : bool
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	individual ready : bool
	individual id : int #the ID of the flit that is currently here
	individual tally : int
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		if has_flit {
			#arb_S_11.busy := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
			#this arbiter isn't modeled yet
			id := 0; #don't give it an individual ID if it was in the system to begin with.
		}
	}
	
	action assigner = { #check the destination to determine which arbiter to assign.
		require has_flit;
		if x_dest = 1 & y_dest = 0 {
			assigned := ape10;
			ready := true;	
		} 
		else if x_dest = 1 & y_dest = 1 { #only if it's going directly north
			if arb_N_10.faulty & ~arb_W_10.faulty & ~arb_W_10.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
				assigned := aw10; #send it to the other arbiter if an10 is blocked.	
				ready := true; #mark that it's ready to receive a packet
			}
			else if arb_N_10.busy { #if the receiver is busy, 
				has_flit := false; #drop the flit to prevent deadlock
				ready := false;
			}
			else { #if it's going north and everything's clear
				require ~arb_N_10.faulty & ~arb_N_10.busy; #double check that it's clear
				assigned := an10; #send north if it needs to go to (1,1)
				ready := true;
			}
		}
		else { #same as 110-123 but for packets not going to (1,1).
			if arb_W_10.faulty & ~arb_N_10.faulty & ~arb_N_10.busy {
				assigned := an10; #send it to the other arbiter if aw10 is blocked.
				ready := true;
			}
			else if arb_W_10.busy {
				has_flit := false;
				ready := false;
			}
			else {
				require ~arb_W_10.faulty & ~arb_N_10.busy;
				assigned := aw10; #if it's not going to (1,1), send it west by default.
				ready := true;
			}
		}
	}
	
	action counter = {
		require has_flit & (id = spec.flit_to_watch); #only proceed if it has a flit and the ID is the assigned ID to watch
		tally := tally + 1;
		if tally > 5 {
			has_flit := false;
			call intf.change_watch;
		}
	}
	
	execute counter before assigner
	
} export r_N_10.assigner 
  export r_N_10.counter




############################
# NODE 00 ##################
############################

object arb_E_00 = {

	#### Evenutal lines are commented out; current lines are not.
	individual faulty : bool
	individual busy : bool
	
	type can_get_from = {r_pe_00,r_e_00,r_n_00} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { #before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
	#	require ~busy & ((r_PE_00.has_flit & r_PE_00.assigned = ae00) | (r_E_00.has_flit & r_E_00.assigned = ae00) | (r_N_00.has_flit & r_N_00.assigned = ae00)); 
		require ~busy & (r_E_00.has_flit & r_E_00.assigned = ae00); 
	}
	
	before move_flit(s:router,r:router,a:arbiter) { #check for simultaneous requests
	#	if r_PE_00.has_flit & r_PE_00.assigned = ae00 {
	#		if r_E_00.has_flit & r_E_00.assigned = ae00 {
	#			if r_N_00.has_flit & r_N_00.assigned = ae00 {
	#				get_from := *;
	#			}
	#			else {
	#				if rand {
	#					get_from := r_pe_00;
	#				}
	#				else {
	#					get_from := r_e_00;
	#				}
	#			}
	#		}
	#		else {
	#			get_from := r_pe_10;
	#		}
	#	}	
	#	else if r_E_00.has_flit & r_E_00.assigned = ae000 {
	#		if r_N_00.has_flit & r_N_00.assigned = ae00 {
	#			if rand {
	#				get_from := r_e_00;
	#			}
	#			else {
	#				get_from := r_n_00;
	#			}
	#		}
	#		else {
	#			get_from := r_e_00;
	#		}
	#	}
	#	else if r_N_00.has_flit & r_N_00.assigned = ae00 {
	#		get_from := r_n_00;
	#	}
	
		get_from := r_e_00;
		
	}
	
	action move_flit(s:router,r:router,a:arbiter) = { 
		call intf.send(s,r,a); #modify the sending relation
		if get_from = r_pe_00 { #send the packet and all its information
		#	r_PE_00.has_flit := false;
		#	r_W_10.x_dest := r_PE_00.x_dest;
		#	r_W_10.y_dest := r_PE_00.y_dest;
		#	r_W_10.id := r_PE_00.id;
		#	r_W_10.has_flit := true;
		}
		else if get_from = r_e_00 {
			r_E_00.has_flit := false;
			r_W_10.x_dest := r_E_00.x_dest;
			r_W_10.y_dest := r_E_00.y_dest;
			r_W_10.id := r_E_00.id;
			r_W_10.has_flit := true;
		}
		else if get_from = r_n_00 {
		#	r_N_00.has_flit := false;
		#	r_W_10.x_dest := r_N_00.x_dest;
		#	r_W_10.y_dest := r_N_00.y_dest;
		#	r_W_10.id := r_N_00.id;
		#	r_W_10.has_flit := true;
		}
	}
} export arb_E_00.move_flit


object r_E_00 = { #this will be more relevant when more parts are added
	individual has_flit : bool
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	individual ready : bool
	individual id : int #the ID of the flit that is currently here
	individual tally : int
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		if has_flit { 
			arb_W_10.busy := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
			id := 0; #don't give it an individual ID if it was in the system to begin with.
		}
	}
	
	action assigner = { #check the destination to determine which arbiter to assign.
		require has_flit;
		if x_dest = 0 & y_dest = 0 {
			#assigned := ape00;
			#ready := true;	
		} 
		else if x_dest = 1 & y_dest = 1 { #only if it's going directly north
			if arb_N_10.faulty & ~arb_W_10.faulty & ~arb_W_10.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
				#assigned := aw10; #send it to the other arbiter if an10 is blocked.	
				#ready := true; #mark that it's ready to receive a packet
			}
			else if arb_N_10.busy { #if the receiver is busy, 
				has_flit := false; #drop the flit to prevent deadlock
				ready := false;
			}
			else { #if it's going north and everything's clear
				#require ~arb_N_10.faulty & ~arb_N_10.busy; #double check that it's clear
				#assigned := an10; #send north if it needs to go to (1,1)
				#ready := true;
			}
		}
		else { #same as 110-123 but for packets not going to (1,1).
			if arb_W_10.faulty & ~arb_N_10.faulty & ~arb_N_10.busy {
				#assigned := an10; #send it to the other arbiter if aw10 is blocked.
				#ready := true;
			}
			else if arb_W_10.busy {
				has_flit := false;
				ready := false;
			}
			else {
				#require ~arb_W_10.faulty & ~arb_N_10.busy;
				#assigned := aw10; #if it's not going to (1,1), send it west by default.
				#ready := true;
			}
		}	
	}
	
	action counter = {
		require has_flit & (id = spec.flit_to_watch); #only proceed if it has a flit and the ID is the assigned ID to watch
		tally := tally + 1;
		if tally > 5 {
			has_flit := false;
			call intf.change_watch;
		}
	}
	
	execute counter before assigner
	
} export r_E_00.assigner
  export r_E_00.counter
  
  
  
  
############################
# NODE 11 ##################
############################

object arb_S_11 = {

	#individual blocked : bool #now local, tells if arbiter is blocked
	
	individual faulty : bool
	individual busy : bool
	
	type can_get_from = {r_pe_11,r_w_11,r_s_11,void} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { #before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
	#	require ~busy & ((r_PE_11.has_flit & r_PE_11.assigned = as11) | (r_W_11.has_flit & r_W_11.assigned = as11) | (r_S_11.has_flit & r_S_11.assigned = as11)); 
		require ~busy & (r_S_11.has_flit & r_S_11.assigned = as11); 
	}
	
	before move_flit(s:router,r:router,a:arbiter) { #check for simultaneous requests
	#	if r_PE_11.has_flit & r_PE_11.assigned = as11 {
	#		if r_W_11.has_flit & r_W_11.assigned = as11 {
	#			if r_S_11.has_flit & r_S_11.assigned = as11 {
	#				get_from := *;
	#			}
	#			else {
	#				if rand {
	#					get_from := r_pe_11;
	#				}
	#				else {
	#					get_from := r_w_11;
	#				}
	#			}
	#		}
	#		else {
	#			get_from := r_pe_11;
	#		}
	#	}	
	#	else if r_W_11.has_flit & r_W_11.assigned = as11 {
	#		if r_S_11.has_flit & r_S_11.assigned = as11 {
	#			if rand {
	#				get_from := r_w_11;
	#			}
	#			else {
	#				get_from := r_s_11;
	#			}
	#		}
	#		else {
	#			get_from := r_w_11;
	#		}
	#	}
	#	else if r_S_11.has_flit & r_S_11.assigned = as11 {
	#		get_from := r_s_11;
	#	}
		
		get_from := r_s_11; #for now, always send to r_S_11 to create livelock
		
		
	}
	
	action move_flit(s:router,r:router,a:arbiter) = { 
		call intf.send(s,r,a); #modify the sending relation
		if get_from = r_pe_11 { #send the packet and all its information
		#	r_PE_11.has_flit := false;
		#	r_N_10.x_dest := r_PE_11.x_dest;
		#	r_N_10.y_dest := r_PE_11.y_dest;
		#	r_N_10.id := r_PE_11.id;
		#	r_N_10.has_flit := true;
		}
		else if get_from = r_w_11 {
		#	r_W_11.has_flit := false;
		#	r_N_10.x_dest := r_W_11.x_dest;
		#	r_N_10.y_dest := r_W_11.y_dest;
		#	r_N_10.id := r_W_11.id;
		#	r_N_10.has_flit := true;
		}
		else if get_from = r_s_11 {
			r_S_11.has_flit := false;
			r_N_10.x_dest := r_S_11.x_dest;
			r_N_10.y_dest := r_S_11.y_dest;
			r_N_10.id := r_S_11.id;
			r_N_10.has_flit := true;
		}
	}
} export arb_S_11.move_flit


object r_S_11 = { #this will be more relevant once more parts are added
	individual has_flit : bool
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	individual ready : bool
	individual id : int #the ID of the flit that is currently here
	individual tally : int
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		if has_flit {
			arb_N_10.busy := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
			id := 0; #don't give it an individual ID if it was in the system to begin with.
		}
	}
	
	action assigner = { #check the destination to determine which arbiter to assign.
		require has_flit;
		if x_dest = 1 & y_dest = 1 {
			#assigned := ape11;
			#ready := true;	
		} 
		else if x_dest = 1 & y_dest = 1 { #only if it's going directly north
			if arb_N_10.faulty & ~arb_W_10.faulty & ~arb_W_10.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
				#assigned := aw10; #send it to the other arbiter if an10 is blocked.	
				#ready := true; #mark that it's ready to receive a packet
			}
			else if arb_N_10.busy { #if the receiver is busy, 
				has_flit := false; #drop the flit to prevent deadlock
				ready := false;
			}
			else { #if it's going north and everything's clear
				#require ~arb_N_10.faulty & ~arb_N_10.busy; #double check that it's clear
				#assigned := an10; #send north if it needs to go to (1,1)
				#ready := true;
			}
		}
		else { #same as 110-123 but for packets not going to (1,1).
			if arb_W_10.faulty & ~arb_N_10.faulty & ~arb_N_10.busy {
				#assigned := an10; #send it to the other arbiter if aw10 is blocked.
				#ready := true;
			}
			else if arb_W_10.busy {
				has_flit := false;
				ready := false;
			}
			else {
				#require ~arb_W_10.faulty & ~arb_N_10.busy;
				#assigned := aw10; #if it's not going to (1,1), send it west by default.
				#ready := true;
			}
		}	
	}
	
	action counter = {
		require has_flit & (id = spec.flit_to_watch); #only proceed if it has a flit and the ID is the assigned ID to watch
		tally := tally + 1;
		if tally > 5 {
			has_flit := false;
			call intf.change_watch;
		}
	}
	
	execute counter before assigner
	
} export r_S_11.assigner
  export r_S_11.counter



####################
#                  #
#  THE INVARIANTS  #
#                  #
####################

#None needed by ivy_check. I'll see if I can come up with some.

