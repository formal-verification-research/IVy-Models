#lang ivy1.7

#describes routing protocol for r_PE_10 and its neighbors




####################
#                  #
#    VARIABLES     #
#                  #
####################


type flit
type arbiter = {an10,aw10,as11,ae00,an00,aw11} #list of arbiters (no underscores to differentiate)
type router = {rn10,rw10,rs11,re00,rpe10} #list of routers (no underscores to differentiate)
type coord = {0,1} #simple 0s and 1s the destination can be set to

# relation link(F:flit,A:arbiter) #attaches an address to the flit - maybe not needed?
relation sending(A:arbiter,R:router,S:router) #a link between an arbiter and the routers sending and receiving the packet

var assigned : arbiter #tells which arbiter is currently assigned
relation blocked(assigned:arbiter)

var x_dest : coord #x-coordinate of destination
var y_dest : coord #y-coordinate of destination





####################
#                  #
#    INTERFACE     #
#                  #
####################



object intf = { 

	# I decided against having quite so many interface actions; now the actions are present inside each of the objects
	# because there were simply too many factors to take into account for each.
	# It would have been difficult to scale.
	
	action check(f:flit,r:router,a:arbiter) #arbiter checks routers to see if they have packets - not super accurate, but the best I could come up with so far
	
	action choose(s:router,r:router,a:arbiter) #if simultaneous requests, choose which to get
	
	action send(f:flit,r:router,a:arbiter) #once the router order is chosen, get flits from those routers and send to the next router

}


object spec = { #The specifications for actions to run

    after init { #on startup, nothing is blocked (there are no problems that could cause deadlock)
       	arb_N_10.blocked := false;
		arb_W_10.blocked := false;
		#arb_S_11.blocked := false;
		#arb_E_00.blocked := false; 
		arb_PE_10.blocked := false;
		
		#this blocked variable tells whether the arbiter can send a flit at that time (it checks the connection from the arbiter to the next router)
		#if a receiving router has a flit, it will tell the arbiter it cannot receive another.
	}
	
	before intf.check {
		require r_PE_10.has_flit | r_W_10.has_flit | r_E_00.has_flit | r_N_10.has_flit | r_S_11.has_flit;
		#require that at least someone has a flit before it can be sent to an arbiter
	}
	
	before intf.choose {
		require (r_PE_10.has_flit & r_W_10.has_flit) | (r_N_10.has_flit & r_W_10.has_flit) | (r_PE_10.has_flit & r_N_10.has_flit);
		#require that two routers have flits to send to the same arbiter in order to choose one to serve
		#eventually I'll add logic to check the destination as well
	}
	
	before intf.send {
		#eventually require something clever
	}
	
} 





#############################
#                           #
# r_PE_10 GENERATES PACKETS #
#                           #
#############################

object r_PE_10 = { 
	
	individual has_flit : bool #whether or not there exists a flit
	individual ready : bool
	
	after init {
		has_flit := *; #maybe it has a flit, maybe it doesn't
		ready := false;
	}
	
	action generate(f:flit,a:arbiter,r:router) = { #choosing the destination
		if has_flit {
			x_dest := *; #arbitrarily chooses
	        y_dest := *; #arbitrarily chooses
	        if x_dest = 1 & y_dest = 1 {
				if arb_N_10.blocked {
					assigned := aw10; #send it to the other arbiter if an10 is blocked.
					
					############# Check if aw10 is blocked as well. Only try alternative if faulty, not busy.
					
					ready := true;
				}
				else {
					assigned := an10; #send north if it needs to go to (1,1)
					ready := true;
				}
			}
	        else { 
				if arb_W_10.blocked {
					assigned := an10; #send it to the other arbiter if aw10 is blocked.
					ready := true;
				}
				else {
					assigned := aw10; #if it's not going to (1,1), send it west by default.
					ready := true;
				}
			}
		}
		
    }
	
	action ship_flit(f:flit,a:arbiter,r:router) = {
		require has_flit & ready;
		call intf.check(f,r,a);
	}

   
} export r_PE_10.generate
export r_PE_10.ship_flit








####################
#                  #
# ALL THE ARBITERS #
#                  #
####################

object arb_N_10 = {

	individual blocked : bool #now local, tells if arbiter is blocked
	type can_get_from = {r_pe_10,r_w_10,r_n_10} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { 							#before the arbiter can get a flit, make sure that it's not blocked, that a flit exists,
		require ~blocked & (r_PE_10.has_flit | r_W_10.has_flit | r_N_10.has_flit) & assigned = an10; #  and that it's assigned here.
		rand := *;
	}
	
	##UPDATE MON 5PM: Added conditions for if all possible sources of flits
	
	before move_flit(f:flit,r:router,s:router,a:arbiter) { #check for simultaneous requests
		require assigned = an10;
		if r_PE_10.has_flit & r_N_10.has_flit & r_W_10.has_flit {
			call intf.choose(s,r,a); ########## Maybe doesn't need to exist  
			get_from := *; #nondeterministically choose just one place to start. the other router will still have a packet at the end.
		}
		else if r_PE_10.has_flit & r_W_10.has_flit { #Nested if statements
			if rand = 1 {
				get_from := r_pe_10;
			}
			else {
				get_from := r_w_10;
			}
		}
		else if r_N_10.has_flit & r_W_10.has_flit {
			if rand = 1 {
				get_from := r_n_10;
			}
			else {
				get_from := r_w_10;
			}
		}
		else if r_PE_10.has_flit & r_N_10.has_flit {
			if rand = 1 {
				get_from := r_pe_10;
			}
			else {
				get_from := r_n_10;
			}
		}
		else if r_PE_10.has_flit {
			get_from := r_pe_10;
		}
		else if r_W_10.has_flit {
			get_from := r_w_10;
		}
		else if r_N_10.has_flit {
			get_from := r_n_10;
		}
	}
	
	action move_flit(f:flit,r:router,s:router,a:arbiter) = { ####### Check the downstream router, too.
		call intf.send(f,r,a); #check the conditions to send a packet
		if get_from = r_pe_10 {
			sending(a,r,s) := true; #I'll do more with this later, perhaps with specific names (see router and arbiter types)
			r_PE_10.has_flit := false;
			r_S_11.has_flit := true;
			sending(a,r,s) := false;
		}
		else if get_from = r_w_10 {
			sending(a,r,s) := true;
			r_W_10.has_flit := false;
			r_S_11.has_flit := true;
			sending(a,r,s) := false;
		}
		else if get_from = r_n_10 {
			sending(a,r,s) := true;
			r_W_10.has_flit := false;
			r_S_11.has_flit := true;
			sending(a,r,s) := false;
		}
	}
} export arb_N_10.move_flit



object arb_W_10 = {

	individual blocked : bool #now local, tells if arbiter is blocked
	type can_get_from = {r_pe_10,r_w_10,r_n_10} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { 							#before the arbiter can get a flit, make sure that it's not blocked, that a flit exists,
		require ~blocked & (r_PE_10.has_flit | r_W_10.has_flit | r_N_10.has_flit) & assigned = aw10; #  and that it's assigned here.
	}
	
	before move_flit(f:flit,r:router,s:router,a:arbiter) { #check for simultaneous requests
		require assigned = aw10;
		if r_PE_10.has_flit & r_N_10.has_flit & r_W_10.has_flit {
			call intf.choose(s,r,a); 
			get_from := *; #nondeterministically choose just one place to start. the other router will still have a packet at the end.
		}
		else if r_PE_10.has_flit & r_W_10.has_flit {
			if rand = 1 {
				get_from := r_pe_10;
			}
			else {
				get_from := r_w_10;
			}
		}
		else if r_N_10.has_flit & r_W_10.has_flit {
			if rand = 1 {
				get_from := r_n_10;
			}
			else {
				get_from := r_w_10;
			}
		}
		else if r_PE_10.has_flit & r_N_10.has_flit {
			if rand = 1 {
				get_from := r_pe_10;
			}
			else {
				get_from := r_n_10;
			}
		}
		else if r_PE_10.has_flit {
			get_from := r_pe_10;
		}
		else if r_W_10.has_flit {
			get_from := r_w_10;
		}
		else if r_N_10.has_flit {
			get_from := r_n_10;
		}
	}
	
	action move_flit(f:flit,r:router,s:router,a:arbiter) = {
		call intf.send(f,r,a); #check the conditions to send a packet
		if get_from = r_pe_10 {
			sending(a,r,s) := true; #I'll do more with this later, perhaps with specific names (see router and arbiter types)
			r_PE_10.has_flit := false; #The sender no longer has the flit
			r_E_00.has_flit := true; #Now the receiver has the flit
			sending(a,r,s) := false; #once it's done, it stops the sending relation
		}
		else if get_from = r_w_10 {
			sending(a,r,s) := true;
			r_W_10.has_flit := false;
			r_E_00.has_flit := true;
			sending(a,r,s) := false;
		}
		else if get_from = r_n_10 {
			sending(a,r,s) := true;
			r_W_10.has_flit := false;
			r_E_00.has_flit := true;
			sending(a,r,s) := false;
		}
	}
} export arb_W_10.move_flit



object arb_PE_10 = {

	individual blocked : bool #now local, tells if arbiter is blocked
	type can_get_from = {r_w_10,r_n_10} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	
	after init { 							#before the arbiter can get a flit, make sure that it's not blocked, that a flit exists,
		require ~blocked & (r_PE_10.has_flit | r_W_10.has_flit | r_N_10.has_flit) & assigned = aw10; #  and that it's assigned here.
	}
	
	before move_flit(f:flit,r:router,s:router,a:arbiter) { #check for simultaneous requests
		if (x_dest = 1 & y_dest = 0) & (r_N_10.has_flit & r_W_10.has_flit) {
			call intf.choose(s,r,a); 
			get_from := *; #nondeterministically choose just one place to start. the other router will still have a packet at the end.
		}
		else if r_W_10.has_flit {
			get_from := r_w_10;
		}
		else if r_N_10.has_flit {
			get_from := r_n_10;
		}
	}
	
	action move_flit(f:flit,r:router,s:router,a:arbiter) = {
		call intf.send(f,r,a); #check the conditions to send a packet
		if get_from = r_w_10 {
			sending(a,r,s) := true;
			r_W_10.has_flit := false;
			sending(a,r,s) := false;
		}
		else if get_from = r_n_10 {
			sending(a,r,s) := true;
			r_N_10.has_flit := false;
			sending(a,r,s) := false;
		}
	}
} export arb_PE_10.move_flit







####################
#                  #
# ALL THE ROUTERS  #
#                  #
####################

object r_W_10 = {
	individual has_flit : bool
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		if has_flit {
			#arb_E_00.blocked := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
			#this arbiter isn't modeled yet
		}
	}
}  

object r_N_10 = {
	individual has_flit : bool
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		if has_flit {
			#arb_S_11.blocked := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
			#this arbiter isn't modeled yet
		}
	}
}  

object r_E_00 = {
	individual has_flit : bool
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		if has_flit { 
			arb_W_10.blocked := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
		}
	}
}  

object r_S_11 = {
	individual has_flit : bool
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		if has_flit {
			arb_N_10.blocked := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
		}
	}
}  



####################
#                  #
#  THE INVARIANTS  #
#                  #
####################

#None needed by ivy_check. I'll see if I can come up with some.

