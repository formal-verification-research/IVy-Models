#lang ivy1.7


####################
#                  #
#    VARIABLES     #
#                  #
####################


type flit
type arbiter = {an10,aw10,as11,ae00,an00,aw11,ape10} #list of arbiters (no underscores to differentiate)
type router = {rn10,rw10,rs11,re00,rpe10} #list of routers (no underscores to differentiate)
type coord = {0,1} #simple 0s and 1s the destination can be set to
type integer
interpret integer -> nat

relation sending(S:router,R:router,A:arbiter) #a link between an arbiter and the routers sending and receiving the packet





####################
#                  #
#    INTERFACE     #
#                  #
####################



object intf = { 
	action check(s:router,r:router,a:arbiter) #arbiter checks routers to see if they have packets - not super accurate, but the best I could come up with so far
	action choose(s:router,r:router,a:arbiter) #if simultaneous requests, choose which to get
	action send(s:router,r:router,a:arbiter) = {#once the router order is chosen, get flits from those routers and send to the next router
		sending(s,r,a) := true;
		sending(s,r,a) := false;
	}
}


object spec = { #The specifications for actions to run

    after init { #on startup, nothing is faulty
       	arb_N_10.faulty := false;
		arb_W_10.faulty := false;
		arb_S_11.faulty := false;
	#	arb_E_00.faulty := false; 
		arb_E_00.faulty := true; 
		
	}
	
	before intf.check {
		require r_PE_10.has_flit | r_W_10.has_flit | r_E_00.has_flit | r_N_10.has_flit | r_S_11.has_flit;
		#require that at least someone has a flit before it can be sent to an arbiter
	}
	
	before intf.choose {
		require (r_PE_10.has_flit & r_W_10.has_flit) | (r_N_10.has_flit & r_W_10.has_flit) | (r_PE_10.has_flit & r_N_10.has_flit);
		#require that two routers have flits to send to the same arbiter in order to choose one to serve
		#eventually I'll add logic to check the destination as well
	}
	
	before intf.send {
		#eventually require something clever
	}
	
} 



object history = { #right now, it only counts the history of arb_N_10 to see if there is a livelock between (0,1) and (1,1)
	
	individual num_loops : integer #amount of times a flit has gone around in a circle
	
	
	before store_history(s:router,r:router,a:arbiter) {
		require r_PE_10.has_flit; #when r_PE_10 generates a flit
		require r_PE_10.assigned = an10;
		require r_PE_10.ready;
	}
	
	action store_history(s:router,r:router,a:arbiter) = { #track the flit's route if it goes in a loop.
		call arb_N_10.move_flit(s,r,a); 
		if r_S_11.has_flit & num_loops < 5 {
			while num_loops < 5 { #if this number is set higher than 4, the assertion below fails.
				assert num_loops < 5; #this can be used to check for livelock, maybe?
				call arb_S_11.move_flit(s,r,a); #see if it wants to keep going in the loop.
				if r_N_10.has_flit {
					num_loops := num_loops + 1; #add 1 to the loop counter
					if num_loops < 5 {
						call arb_N_10.move_flit(s,r,a); #let it keep going if it hasn't gone 4 times yet.
					}
					else {
						r_S_11.has_flit := false; #drop the flit if it's gone around more than 4 times
						num_loops := 0;	#reset the counter if the flit gets dropped
					}
					
				}
				else {
					num_loops := 0; #reset the number of loops if the flit goes somewhere else
				}
			}
		}
		else if num_loops >= 5 { #drop the flit if it's gone around more than 4 times
		#	assert num_loops < 5; # For testing purposes... it causes 2 failed checks.
			r_S_11.has_flit := false;
			num_loops := 0; 
		}
	}
	
	execute store_history before intf.check
	
	before intf.send {
		#require num_loops < 5; #eventually make sure there is no livelock before sending...
	}
	
} export history.store_history



#############################
#                           #
# r_PE_10 GENERATES PACKETS #
#                           #
#############################

object r_PE_10 = { 
	
	individual has_flit : bool #whether or not there exists a flit
	individual ready : bool
	
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	
	after init {
		has_flit := *; #maybe it has a flit, maybe it doesn't
		ready := false; #it's not ready to send the flit quite yet.
	}
	
	action generate(f:flit,a:arbiter,r:router) = { #choosing the destination
		
		if has_flit {
			x_dest := *; #arbitrarily chooses
	        y_dest := *; #arbitrarily chooses
	        if x_dest = 1 & y_dest = 1 { #only if it's going directly north
				if arb_N_10.faulty & ~arb_W_10.faulty & ~arb_W_10.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
					assigned := aw10; #send it to the other arbiter if an10 is blocked.	
					ready := true; #mark that it's ready to receive a packet
				}
				else if arb_N_10.busy { #if the receiver is busy, 
					has_flit := false; #drop the flit to prevent deadlock
					ready := false;
				}
				else { #if it's going north and everything's clear
					require ~arb_N_10.faulty & ~arb_N_10.busy; #double check that it's clear
					assigned := an10; #send north if it needs to go to (1,1)
					ready := true;
				}
			}
	        else { #same as 110-123 but for packets not going to (1,1).
				if arb_W_10.faulty & ~arb_N_10.faulty & ~arb_N_10.busy {
					assigned := an10; #send it to the other arbiter if aw10 is blocked.
					ready := true;
				}
				else if arb_W_10.busy {
					has_flit := false;
					ready := false;
				}
				else {
					require ~arb_W_10.faulty & ~arb_N_10.busy;
					assigned := aw10; #if it's not going to (1,1), send it west by default.
					ready := true;
				}
			}
		}
		
    }
	
	action send_flit(s:router,r:router,a:arbiter) = {
		require has_flit & ready;
		call intf.check(s,r,a);
	}

   
} export r_PE_10.generate
export r_PE_10.send_flit








####################
#                  #
# ALL THE ARBITERS #
#                  #
####################

# The arbiters only check which arbiter is assigned, not the eventual destination.

object arb_N_10 = {

	individual faulty : bool
	individual busy : bool
	
	type can_get_from = {r_pe_10,r_w_10,r_n_10,void} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { #before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
		require ~busy & ((r_PE_10.has_flit & r_PE_10.assigned = an10) | (r_W_10.has_flit & r_W_10.assigned = an10) | (r_N_10.has_flit & r_N_10.assigned = an10)); 
		rand := *; #arbitrarily choose either a true or a false.
	}
		
	before move_flit(s:router,r:router,a:arbiter) { #check for simultaneous requests
		if r_PE_10.has_flit & r_PE_10.assigned = an10 {
			if r_W_10.has_flit & r_W_10.assigned = an10 {
				if r_N_10.has_flit & r_N_10.assigned = an10 {
					get_from := *;
				}
				else {
					if rand {
						get_from := r_pe_10;
					}
					else {
						get_from := r_w_10;
					}
				}
			}
			else {
				get_from := r_pe_10;
			}
		}	
		else if r_W_10.has_flit & r_W_10.assigned = an10 {
			if r_N_10.has_flit & r_N_10.assigned = an10 {
				if rand {
					get_from := r_w_10;
				}
				else {
					get_from := r_n_10;
				}
			}
			else {
				get_from := r_w_10;
			}
		}
		else if r_N_10.has_flit & r_N_10.assigned = an10 {
			get_from := r_n_10;
		}
	}
	
	action move_flit(s:router,r:router,a:arbiter) = { 
		call intf.send(s,r,a); #modify the sending relation
		if get_from = r_pe_10 {
			r_PE_10.has_flit := false; #send the packet and all its information
			r_S_11.x_dest := r_PE_10.x_dest;
			r_S_11.y_dest := r_PE_10.y_dest;
			r_S_11.has_flit := true;
		}
		else if get_from = r_w_10 {
			r_W_10.has_flit := false;
			r_S_11.x_dest := r_W_10.x_dest;
			r_S_11.y_dest := r_W_10.y_dest;
			r_S_11.has_flit := true;
		}
		else if get_from = r_n_10 {
			r_N_10.has_flit := false;
			r_S_11.x_dest := r_N_10.x_dest;
			r_S_11.y_dest := r_N_10.y_dest;
			r_S_11.has_flit := true;
		}
	}
} export arb_N_10.move_flit



object arb_W_10 = {
	
	individual faulty : bool
	individual busy : bool
	
	type can_get_from = {r_pe_10,r_w_10,r_n_10} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { 							#before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
		require ~busy & ((r_PE_10.has_flit & r_PE_10.assigned = aw10) | (r_W_10.has_flit & r_W_10.assigned = aw10) | (r_N_10.has_flit & r_N_10.assigned = aw10)); 
	}
	
	before move_flit(s:router,r:router,a:arbiter) { #check for simultaneous requests
		if r_PE_10.has_flit & r_PE_10.assigned = aw10 {
			if r_W_10.has_flit & r_W_10.assigned = aw10 {
				if r_N_10.has_flit & r_N_10.assigned = aw10 {
					get_from := *;
				}
				else {
					if rand {
						get_from := r_pe_10;
					}
					else {
						get_from := r_w_10;
					}
				}
			}
			else {
				get_from := r_pe_10;
			}
		}	
		else if r_W_10.has_flit & r_W_10.assigned = aw10 {
			if r_N_10.has_flit & r_N_10.assigned = aw10 {
				if rand {
					get_from := r_w_10;
				}
				else {
					get_from := r_n_10;
				}
			}
			else {
				get_from := r_w_10;
			}
		}
		else if r_N_10.has_flit & r_N_10.assigned = aw10 {
			get_from := r_n_10;
		}
		
	}
	
	action move_flit(s:router,r:router,a:arbiter) = { 
		call intf.send(s,r,a); #modify the sending relation
		if get_from = r_pe_10 { #send the packet and all its information
			r_PE_10.has_flit := false;
			r_E_00.x_dest := r_PE_10.x_dest;
			r_E_00.y_dest := r_PE_10.y_dest;
			r_E_00.has_flit := true;
		}
		else if get_from = r_w_10 {
			r_W_10.has_flit := false;
			r_E_00.x_dest := r_W_10.x_dest;
			r_E_00.y_dest := r_W_10.y_dest;
			r_E_00.has_flit := true;
		}
		else if get_from = r_n_10 {
			r_N_10.has_flit := false;
			r_E_00.x_dest := r_N_10.x_dest;
			r_E_00.y_dest := r_N_10.y_dest;
			r_E_00.has_flit := true;
		}
		
	}
} export arb_W_10.move_flit





object arb_PE_10 = {
	
	individual busy : bool
	
	type can_get_from = {r_w_10,r_n_10} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	
	after init { 							#before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
		require ~busy & ((r_W_10.has_flit & r_W_10.assigned = ape10) | (r_N_10.has_flit & r_N_10.assigned = ape10)); 
	}
	
	before move_flit(s:router,r:router,a:arbiter) { #check for simultaneous requests
		if r_N_10.has_flit & r_N_10.assigned = ape10 {
			if r_W_10.has_flit & r_W_10.assigned = ape10 {
				get_from := *;
			}
			else {
				get_from := r_n_10;
			}
		}
		else if r_W_10.has_flit & r_W_10.assigned = ape10 {
			get_from := r_w_10;
		}
		
	}
	
	action move_flit(s:router,r:router,a:arbiter) = { 
		call intf.send(s,r,a); #modify the sending relation
		if get_from = r_w_10 {
			r_W_10.has_flit := false;
		}
		else if get_from = r_n_10 {
			r_N_10.has_flit := false;
		}
	}
} export arb_PE_10.move_flit







####################
#                  #
# ALL THE ROUTERS  #
#                  #
####################

object r_W_10 = {
	individual has_flit : bool
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	individual ready : bool
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		if has_flit {
			arb_E_00.busy := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
		}
	}
	
	action assigner = { #check the destination to determine which arbiter to assign.
		require has_flit;
		if x_dest = 1 & y_dest = 0 {
			assigned := ape10;
			ready := true;	
		} else if x_dest = 1 & y_dest = 1 { #only if it's going directly north
			if arb_N_10.faulty & ~arb_W_10.faulty & ~arb_W_10.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
				assigned := aw10; #send it to the other arbiter if an10 is blocked.	
				ready := true; #mark that it's ready to receive a packet
			}
			else if arb_N_10.busy { #if the receiver is busy, 
				has_flit := false; #drop the flit to prevent deadlock
				ready := false;
			}
			else { #if it's going north and everything's clear
				require ~arb_N_10.faulty & ~arb_N_10.busy; #double check that it's clear
				assigned := an10; #send north if it needs to go to (1,1)
				ready := true;
			}
		}
		else { #same as 110-123 but for packets not going to (1,1).
			if arb_W_10.faulty & ~arb_N_10.faulty & ~arb_N_10.busy {
				assigned := an10; #send it to the other arbiter if aw10 is blocked.
				ready := true;
			}
			else if arb_W_10.busy {
				has_flit := false;
				ready := false;
			}
			else {
				require ~arb_W_10.faulty & ~arb_N_10.busy;
				assigned := aw10; #if it's not going to (1,1), send it west by default.
				ready := true;
			}
		}	
	}
	
} export r_W_10.assigner



object r_N_10 = {
	individual has_flit : bool
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	individual ready : bool
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		if has_flit {
			#arb_S_11.busy := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
			#this arbiter isn't modeled yet
		}
	}
	
	action assigner = { #check the destination to determine which arbiter to assign.
		require has_flit;
		if x_dest = 1 & y_dest = 0 {
			assigned := ape10;
			ready := true;	
		} 
		else if x_dest = 1 & y_dest = 1 { #only if it's going directly north
			if arb_N_10.faulty & ~arb_W_10.faulty & ~arb_W_10.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
				assigned := aw10; #send it to the other arbiter if an10 is blocked.	
				ready := true; #mark that it's ready to receive a packet
			}
			else if arb_N_10.busy { #if the receiver is busy, 
				has_flit := false; #drop the flit to prevent deadlock
				ready := false;
			}
			else { #if it's going north and everything's clear
				require ~arb_N_10.faulty & ~arb_N_10.busy; #double check that it's clear
				assigned := an10; #send north if it needs to go to (1,1)
				ready := true;
			}
		}
		else { #same as 110-123 but for packets not going to (1,1).
			if arb_W_10.faulty & ~arb_N_10.faulty & ~arb_N_10.busy {
				assigned := an10; #send it to the other arbiter if aw10 is blocked.
				ready := true;
			}
			else if arb_W_10.busy {
				has_flit := false;
				ready := false;
			}
			else {
				require ~arb_W_10.faulty & ~arb_N_10.busy;
				assigned := aw10; #if it's not going to (1,1), send it west by default.
				ready := true;
			}
		}
	
	}
} export r_N_10.assigner 




############################
# NODE 00 ##################
############################

object arb_E_00 = {

	#### Evenutal lines are commented out; current lines are not.
	individual faulty : bool
	individual busy : bool
	
	type can_get_from = {r_pe_00,r_e_00,r_n_00} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { #before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
	#	require ~busy & ((r_PE_00.has_flit & r_PE_00.assigned = ae00) | (r_E_00.has_flit & r_E_00.assigned = ae00) | (r_N_00.has_flit & r_N_00.assigned = ae00)); 
		require ~busy & (r_E_00.has_flit & r_E_00.assigned = ae00); 
	}
	
	before move_flit(s:router,r:router,a:arbiter) { #check for simultaneous requests
	#	if r_PE_00.has_flit & r_PE_00.assigned = ae00 {
	#		if r_E_00.has_flit & r_E_00.assigned = ae00 {
	#			if r_N_00.has_flit & r_N_00.assigned = ae00 {
	#				get_from := *;
	#			}
	#			else {
	#				if rand {
	#					get_from := r_pe_00;
	#				}
	#				else {
	#					get_from := r_e_00;
	#				}
	#			}
	#		}
	#		else {
	#			get_from := r_pe_10;
	#		}
	#	}	
	#	else if r_E_00.has_flit & r_E_00.assigned = ae000 {
	#		if r_N_00.has_flit & r_N_00.assigned = ae00 {
	#			if rand {
	#				get_from := r_e_00;
	#			}
	#			else {
	#				get_from := r_n_00;
	#			}
	#		}
	#		else {
	#			get_from := r_e_00;
	#		}
	#	}
	#	else if r_N_00.has_flit & r_N_00.assigned = ae00 {
	#		get_from := r_n_00;
	#	}
	
		get_from := r_e_00;
		
	}
	
	action move_flit(s:router,r:router,a:arbiter) = { 
		call intf.send(s,r,a); #modify the sending relation
		if get_from = r_pe_00 { #send the packet and all its information
		#	r_PE_00.has_flit := false;
		#	r_W_10.x_dest := r_PE_00.x_dest;
		#	r_W_10.y_dest := r_PE_00.y_dest;
		#	r_W_10.has_flit := true;
		}
		else if get_from = r_e_00 {
			r_E_00.has_flit := false;
			r_W_10.x_dest := r_E_00.x_dest;
			r_W_10.y_dest := r_E_00.y_dest;
			r_W_10.has_flit := true;
		}
		else if get_from = r_n_00 {
		#	r_N_00.has_flit := false;
		#	r_W_10.x_dest := r_N_00.x_dest;
		#	r_W_10.y_dest := r_N_00.y_dest;
		#	r_W_10.has_flit := true;
		}
	}
} export arb_E_00.move_flit


object r_E_00 = { #this will be more relevant when more parts are added
	individual has_flit : bool
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	individual ready : bool
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		if has_flit { 
			arb_W_10.busy := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
		}
	}
	
	action assigner = { #check the destination to determine which arbiter to assign.
		require has_flit;
		if x_dest = 0 & y_dest = 0 {
			#assigned := ape00;
			#ready := true;	
		} 
		else if x_dest = 1 & y_dest = 1 { #only if it's going directly north
			if arb_N_10.faulty & ~arb_W_10.faulty & ~arb_W_10.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
				#assigned := aw10; #send it to the other arbiter if an10 is blocked.	
				#ready := true; #mark that it's ready to receive a packet
			}
			else if arb_N_10.busy { #if the receiver is busy, 
				has_flit := false; #drop the flit to prevent deadlock
				ready := false;
			}
			else { #if it's going north and everything's clear
				#require ~arb_N_10.faulty & ~arb_N_10.busy; #double check that it's clear
				#assigned := an10; #send north if it needs to go to (1,1)
				#ready := true;
			}
		}
		else { #same as 110-123 but for packets not going to (1,1).
			if arb_W_10.faulty & ~arb_N_10.faulty & ~arb_N_10.busy {
				#assigned := an10; #send it to the other arbiter if aw10 is blocked.
				#ready := true;
			}
			else if arb_W_10.busy {
				has_flit := false;
				ready := false;
			}
			else {
				#require ~arb_W_10.faulty & ~arb_N_10.busy;
				#assigned := aw10; #if it's not going to (1,1), send it west by default.
				#ready := true;
			}
		}	
	}
} export r_E_00.assigner
  
  
  
  
############################
# NODE 11 ##################
############################

object arb_S_11 = {

	#individual blocked : bool #now local, tells if arbiter is blocked
	
	individual faulty : bool
	individual busy : bool
	
	type can_get_from = {r_pe_11,r_w_11,r_s_11,void} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { #before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
	#	require ~busy & ((r_PE_11.has_flit & r_PE_11.assigned = as11) | (r_W_11.has_flit & r_W_11.assigned = as11) | (r_S_11.has_flit & r_S_11.assigned = as11)); 
		require ~busy & (r_S_11.has_flit & r_S_11.assigned = as11); 
	}
	
	before move_flit(s:router,r:router,a:arbiter) { #check for simultaneous requests
	#	if r_PE_11.has_flit & r_PE_11.assigned = as11 {
	#		if r_W_11.has_flit & r_W_11.assigned = as11 {
	#			if r_S_11.has_flit & r_S_11.assigned = as11 {
	#				get_from := *;
	#			}
	#			else {
	#				if rand {
	#					get_from := r_pe_11;
	#				}
	#				else {
	#					get_from := r_w_11;
	#				}
	#			}
	#		}
	#		else {
	#			get_from := r_pe_11;
	#		}
	#	}	
	#	else if r_W_11.has_flit & r_W_11.assigned = as11 {
	#		if r_S_11.has_flit & r_S_11.assigned = as11 {
	#			if rand {
	#				get_from := r_w_11;
	#			}
	#			else {
	#				get_from := r_s_11;
	#			}
	#		}
	#		else {
	#			get_from := r_w_11;
	#		}
	#	}
	#	else if r_S_11.has_flit & r_S_11.assigned = as11 {
	#		get_from := r_s_11;
	#	}
		
		get_from := r_s_11; #for now, always send to r_S_11 to create livelock
		
		
	}
	
	action move_flit(s:router,r:router,a:arbiter) = { 
		call intf.send(s,r,a); #modify the sending relation
		if get_from = r_pe_11 { #send the packet and all its information
		#	r_PE_11.has_flit := false;
		#	r_N_10.x_dest := r_PE_11.x_dest;
		#	r_N_10.y_dest := r_PE_11.y_dest;
		#	r_N_10.has_flit := true;
		}
		else if get_from = r_w_11 {
		#	r_W_11.has_flit := false;
		#	r_N_10.x_dest := r_W_11.x_dest;
		#	r_N_10.y_dest := r_W_11.y_dest;
		#	r_N_10.has_flit := true;
		}
		else if get_from = r_s_11 {
			r_S_11.has_flit := false;
			r_N_10.x_dest := r_S_11.x_dest;
			r_N_10.y_dest := r_S_11.y_dest;
			r_N_10.has_flit := true;
		}
	}
} export arb_S_11.move_flit


object r_S_11 = { #this will be more relevant once more parts are added
	individual has_flit : bool
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	individual ready : bool
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		if has_flit {
			arb_N_10.busy := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
		}
	}
	
	action assigner = { #check the destination to determine which arbiter to assign.
		require has_flit;
		if x_dest = 1 & y_dest = 1 {
			#assigned := ape11;
			#ready := true;	
		} 
		else if x_dest = 1 & y_dest = 1 { #only if it's going directly north
			if arb_N_10.faulty & ~arb_W_10.faulty & ~arb_W_10.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
				#assigned := aw10; #send it to the other arbiter if an10 is blocked.	
				#ready := true; #mark that it's ready to receive a packet
			}
			else if arb_N_10.busy { #if the receiver is busy, 
				has_flit := false; #drop the flit to prevent deadlock
				ready := false;
			}
			else { #if it's going north and everything's clear
				#require ~arb_N_10.faulty & ~arb_N_10.busy; #double check that it's clear
				#assigned := an10; #send north if it needs to go to (1,1)
				#ready := true;
			}
		}
		else { #same as 110-123 but for packets not going to (1,1).
			if arb_W_10.faulty & ~arb_N_10.faulty & ~arb_N_10.busy {
				#assigned := an10; #send it to the other arbiter if aw10 is blocked.
				#ready := true;
			}
			else if arb_W_10.busy {
				has_flit := false;
				ready := false;
			}
			else {
				#require ~arb_W_10.faulty & ~arb_N_10.busy;
				#assigned := aw10; #if it's not going to (1,1), send it west by default.
				#ready := true;
			}
		}	
	}
} export r_S_11.assigner



####################
#                  #
#  THE INVARIANTS  #
#                  #
####################

#None needed by ivy_check. I'll see if I can come up with some.

