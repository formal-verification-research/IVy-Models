#lang ivy1.7

type coord #coordinates are 1 or 0 in this model... 
interpret coord -> bv[1] #easily expanded to 3x3 using bv[2]

type integer #for the tallies, I still haven't found a good way around it
interpret integer -> bv[3] #still working on figuring out an
#uninterpreted type.

object counter = {
    type c
    relation (X:c < Y:c)
    action incr(inp:c) returns (out:c)

    object spec = {
        property [transitivity] X:c < Y & Y < Z -> X < Z
        property [antisymmetry] ~(X:c < Y & Y < X)

        after incr {
            assert inp < out
        }
    }
}

# object intf = { 
	
# 	# individual total_moves : integer #tracks the total number of moves in the system
# 	individual max_dim : coord #used to set how many nodes there are each direction
	
# 	after init {
# 		# total_moves := 0; #start with 0 total moves
# 		max_dim := 0 - 1; #set the max height and width to the max value of the vit bector (in bv[2] 0-1=3)
# 	}
	
# 	# action move = { #called by the send_direction actions below
# 	# 	total_moves := total_moves + 1; #increment total_moves
# 	# }
		
# } #end intf

object spec = { 
	
	individual max_dim : coord #used to set how many nodes there
    #are each direction
        individual cnt : counter.c

        after init {
		max_dim := 0 - 1; #set the max height and width to the
	#max value of the vit bector (in bv[2] 0-1=3)
	        cnt := 0
	}
    
} #end spec



object packet = { #now everything runs from the packet's point of view
	
	individual x_dest : coord #destination x coordinate
	individual y_dest : coord #destination y coordinate
	
	individual x_cur : coord #current x coordinate
	individual y_cur : coord #current y coordinate
	individual cnt : counter.c
	
	after init {
		x_dest := *; #it can have any destination
		y_dest := *; #it can have any destination
		x_cur := *; #it can start anywhere
		y_cur := *; #it can start anywhere
		cnt := 0; #start with a cnt of 0
	}
	
	before route { #before routing the packet
		assert x_cur <= spec.max_dim; #make sure the packet is within the max dimmensions
		assert y_cur <= spec.max_dim; #make sure the packet is within the max dimmensions
		assert x_dest <= spec.max_dim; #make sure the packet wants to go within the max dimmensions
		assert y_dest <= spec.max_dim; #make sure the packet wants to go within the max dimmensions
	}
	
	action route = {
		if y_dest = y_cur { #if it is at the right y coordinate
			if x_dest = x_cur { #if it is at the right x coordinate
				cnt := 0; #do nothing, stay here
			}
			else if x_dest < x_cur { #if it needs to go west
		                call send_west; #send west
		                #call intf.move; #increment the total counter
			}
			else if x_dest > x_cur { #if it needs to go east
		                call send_east; #send east
				#call intf.move; #increment the total counter
			}; #endif
		}
		else if y_dest < y_cur { #if it needs to go south
	                        call send_south; #send south
                               #call intf.move; #increment the total counter
		}
		else if y_dest > y_cur { #if it needs to go north
	                        call send_north; #send north
			        #call intf.move; #increment the total counter
		}; #endif
	}		
	
	action send_north = {
		#ensure y_dest > 0; #make sure the y destination is not 0
		y_cur := y_cur + 1; #set the current position to 1 to the north
		if y_cur ~= y_dest { #if it hasn't arrived at its y destination
	                   #call incr #increment the packet counter
	                   call counter.incr(cnt)	                        	    
		}; #endif
	}
	
	action send_south = {
		ensure y_dest < spec.max_dim; #make sure the destination is within the right range
		y_cur := y_cur - 1; #set the current position to 1 to the south
		if y_cur ~= y_dest { #if it hasn't arrived at its y destination
	                   #call incr #increment the packet counter
	                   call counter.incr(cnt)	                        	    
		}; #endif
	}
	
	action send_east = {
		ensure x_dest > 0; #make sure the destination is not 0
		x_cur := x_cur + 1; #set the current position to 1 to the east
		if x_cur ~= x_dest { #if it hasn't arrived at its x destination
	                   #call incr #increment the packet counter
	                   call counter.incr(cnt)	                        	    
		}; #endif
	}
	
	action send_west = {
		ensure x_dest < spec.max_dim; #make sure the destination is within the right range
		x_cur := x_cur - 1; #set the current position to 1 to the west
		if x_cur ~= x_dest { #if it hasn't arrived at its x destination
	                   #call incr #increment the packet counter
	                   call counter.incr(cnt)	                        	    
		}; #endif
	}
	
	# action incr = {
	# 	cnt := cnt + 1; #add 1 to the packet counter
	# }
	
	export route #the routing decision is exported to the environment 
	
} #end packet

