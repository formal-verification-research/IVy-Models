#lang ivy1.7

#this is for the 2x2 model.

# Routing decisions based on the drawind from page 16 of 
#"An Improved Fault-Tolerant Routing Algorithm for a 
# Network-on-Chip Derived with Formal Analysis"

type int
interpret int -> bv[8]

type coord
interpret coord -> bv[1]

type router = {rs11,rn10,rw11,re01,rn00,rs01,re00,rw10}
type nodes = {00,01,10,11}

var livelock_exists : bool

object intf = {
	
	individual s : int #S in documentation
	individual l : int #L in documentation
	individual n : int #N in documentation
	
	after init {
		n := 2; #N in documentation
		l := 4 * (n - 1); #L in documentation
		s := l + 1; #S in documentation
		ensure intf.s > intf.n;
		livelock_exists := false;
	}
	
} #end intf

object counter = {
	
	individual rs11c : int
	individual rn10c : int
	individual rw11c : int
	individual re01c : int
	individual rn00c : int
	individual rs01c : int
	individual re00c : int
	individual rw10c : int
	individual count : int
	
	axiom X:int < 0 - 1 #it fails terribly until this axiom is added.
	#I think it only says that the integers don't "roll over" i.e. 255 + 1 != 0
	
	after init {
		rs11c := 0;
		rn10c := 0;
		rw11c := 0;
		re01c := 0;
		rn00c := 0;
		rs01c := 0;
		re00c := 0;
		rw10c := 0;
		count := 0;
	} 
	
	action incr = {
		require count ~= 0 - 1;
		count := count + 1;
		if packet.cur = rs11 {
			rs11c := rs11c + 1;
			ensure rs11c <= count;
		} else 
		if packet.cur = rn10 {
			rn10c := rn10c + 1;
			ensure rn10c <= count;
		} else
		if packet.cur = rw11 {
			rw11c := rw11c + 1;
			ensure rw11c <= count;
		} else 
		if packet.cur = re01 {
			re01c := re01c + 1;
			ensure re01c <= count;
		} else
		if packet.cur = rn00 {
			rn00c := rn00c + 1;
			ensure rn00c <= count;
		} else 
		if packet.cur = rs01 {
			rs01c := rs01c + 1;
			ensure rs01c <= count;
		} else
		if packet.cur = re00 {
			re00c := re00c + 1;
			ensure re00c <= count;
		} else 
		if packet.cur = rw10 {
			rw10c := rw10c + 1;
			ensure rw10c <= count;
		};
		call verify;
	}
	
	action verify = {
		assert rs11c <= count;
		assert rn10c <= count;
		assert rw11c <= count;
		assert re01c <= count;
		assert rn00c <= count;
		assert rs01c <= count;
		assert re00c <= count;
		assert rw10c <= count;
		if count = intf.s {
			 if rs11c > 1 | rn10c > 1 | 
				rw11c > 1 | re01c > 1 | 
				rn00c > 1 | rs01c > 1 | 
				re00c > 1 | rw10c > 1 {
					livelock_exists := true;
			}
		}	
	}
	
	invariant (rs11c <= 1 & rn10c <= 1 & rw11c <= 1 & re01c <= 1 & rn00c <= 1 & rs01c <= 1 & re00c <= 1 & rw10c > 1) | livelock_exists
	
} #end counter

object packet = {
	
	individual dest : nodes #destination y coordinate
	individual cur : router #cur x coordinate
	
	after init {
		dest := *; #it can have any destination
		cur := *; #it can have any destination
		counter.count := 0; #start with a count of 0
	}
	
	#Sadly, I had to hard-code the routing decisions...
	#I'm working on coming up with a better way to do this.
	#The leader election ring example gave me a couple of ideas.
	#See page 16's arrows for my decision-making system.
	action route = {
		if dest = 00 {
			if cur = rs11 {
				call change_direction;
			} else 
			if cur = rn10 {
				call send_clockwise;
			} else
			if cur = rw11 {
				call send_clockwise;
			} else 
			if cur = re01 {
				call send_counterclock;
			} else
			if cur = rn00 {
				call done;
			} else 
			if cur = rs01 {
				call change_direction;
			} else
			if cur = re00 {
				call done;
			} else 
			if cur = rw10 {
				call send_clockwise;
			};
		} else
		if dest = 10 {
			if cur = rs11 {
				call change_direction;
			} else 
			if cur = rn10 {
				call done;
			} else
			if cur = rw11 {
				call send_clockwise;
			} else 
			if cur = re01 {
				call send_counterclock;
			} else
			if cur = rn00 {
				call send_counterclock;
			} else 
			if cur = rs01 {
				call send_clockwise;
			} else
			if cur = re00 {
				call change_direction;
			} else 
			if cur = rw10 {
				call done;
			};
		} else
		if dest = 01 {
			if cur = rs11 {
				call send_counterclock;
			} else 
			if cur = rn10 {
				call send_clockwise;
			} else
			if cur = rw11 {
				call change_direction;
			} else 
			if cur = re01 {
				call done;
			} else
			if cur = rn00 {
				call change_direction;
			} else 
			if cur = rs01 {
				call done;
			} else
			if cur = re00 {
				call send_clockwise;
			} else 
			if cur = rw10 {
				call send_clockwise;
			};
		} else
		if dest = 11 {
			if cur = rs11 {
				call done;
			} else 
			if cur = rn10 {
				call send_clockwise;
			} else
			if cur = rw11 {
				call done;
			} else 
			if cur = re01 {
				call change_direction;
			} else
			if cur = rn00 {
				call send_counterclock;
			} else 
			if cur = rs01 {
				call send_clockwise;
			} else
			if cur = re00 {
				call send_clockwise;
			} else 
			if cur = rw10 {
				call send_counterclock;
			};
		};
	}
	
	#It's a bit clumsy, but I'm working on making it better.
	
	action send_clockwise = {
		if cur = rw11 {
			cur := rn10;
		} else 
		if cur = rn10 {
			cur := re00;
		} else
		if cur = re00 {
			cur := rs01;
		} else 
		if cur = rs01 {
			cur := rw11;
		};
		call counter.incr
	}
	
	action send_counterclock = {
		if cur = rs11 {
			cur := re01;
		} else 
		if cur = re01 {
			cur := rn00;
		} else
		if cur = rn00 {
			cur := rw10;
		} else 
		if cur = rw10 {
			cur := rs11;
		};
		call counter.incr
	}
	
	action change_direction = {
		
		if cur = rs11 {
			cur := rn10;
		} else 
		if cur = rn10 {
			cur := rs11;
		} else
		if cur = rw11 {
			cur := re01;
		} else 
		if cur = re01 {
			cur := rw11;
		} else
		if cur = rn00 {
			cur := rs01;
		} else 
		if cur = rs01 {
			cur := rn00;
		} else
		if cur = re00 {
			cur := rw10;
		} else 
		if cur = rw10 {
			cur := re00;
		};
		call counter.incr
	}
	
	action done = {
		counter.count := 0;
		cur := *; #keep simulating
		dest := *; #keep simulating
	}
	
	export route
	
} #end packet

#I'm still cooking up some invariants.

