#lang ivy1.7

# VERSION NOTES:
# This version is a scaled-down version of the model. It represents just (1,0) and its immediate neighbors.


###########################################################
########### VARIABLES #####################################
###########################################################

type int #maybe there's a good way to use abstract datatypes ( http://microsoft.github.io/ivy/examples/datatypes.html ) instead of integers...
interpret int -> bv[16] #right now, int just means it has the integer type.

type arbiter = {void,an10,aw10,ape10,an00,ae00,ape00,as01,ae01,ape01,as11,aw11,ape11} #list of arbiters (no underscores to differentiate)
type router = {null,rn10,rw10,rpe10,rn00,re00,rpe00,rs01,re01,rpe01,rs11,rw11,rpe11} #list of routers (no underscores to differentiate)
type coord = {0,1} #simple 0s and 1s the destination can be set to

relation sending(S:router,R:router,A:arbiter) #a link between an arbiter and the routers sending and receiving the packet

var flit_to_watch : int
var last_generated : int




###########################################################
########### INTERFACE #####################################
###########################################################

object intf = { 
	action change_watch = {
		flit_to_watch := *;
		assert flit_to_watch > 0;
	}
	action check(s:router,r:router,a:arbiter) #arbiter checks routers to see if they have packets - not super accurate, but the best I could come up with so far
	action choose(s:router,r:router,a:arbiter) #if simultaneous requests, choose which to get
	action send #once the router order is chosen, get flits from those routers and send to the next router
	export check

} #closeob

object spec = { #The specifications for actions to run

    after init { #on startup, nothing is faulty
		arb_N_10.faulty := false;
		arb_W_10.faulty := false;
	#	arb_S_01.faulty := false;
	#	arb_E_01.faulty := false;
		arb_S_11.faulty := false;
	#	arb_W_11.faulty := false;
		arb_E_00.faulty := false;
	#	arb_N_00.faulty := false;
		flit_to_watch := *;
		last_generated := 0;
	}
	
	before intf.change_watch {
		flit_to_watch := *;
	}
	
	before intf.check {
		require ~(r_W_10.has_flit & (r_W_10.assigned = an10) & r_S_11.has_flit & (r_W_10.assigned = aw11)); #preventing deadlock???
		#this will work much better once the model has been expanded to include the other nodes.
	}
	
	before intf.choose {
		
	}
	
	before intf.send {
		
	}
	
	#Checking for busy routers:
	
	before intf.check {
		if r_N_10.has_flit {
			arb_S_11.busy := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
		}
		else {
			arb_S_11.busy := false; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
		}
	}
	before intf.check {
		if r_W_10.has_flit {
			arb_E_00.busy := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
		}
		else {
			arb_E_00.busy := false; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
		}
	}
	before intf.check {
		if r_S_11.has_flit {
			arb_N_10.busy := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
		}
		else {
			arb_N_10.busy := false; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
		}
	}
	before intf.check {
		if r_E_00.has_flit {
			arb_W_10.busy := true; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
		}
		else {
			arb_W_10.busy := false; #when there is already a flit here, it appears to be blocked (the arbiter can't send another)
		}
	}
} #closeob




###########################################################
########### NODE (1,0) #################################### DONE
###########################################################

object r_PE_10 = { 
	
	individual has_flit : bool #whether or not there exists a flit
	individual ready : bool
	
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	
	individual id : int #the ID of the flit that is currently here
	
	after init {
		has_flit := *; #maybe it has a flit, maybe it doesn't
		ready := false; #it's not ready to send the flit quite yet.
		assigned := void;
	}
	
	action generate = { #choosing the destination
		require has_flit;
		x_dest := *; #arbitrarily chooses
		y_dest := *; #arbitrarily chooses
		id := last_generated + 1; #give the flit a sequential ID
		require id > last_generated;
		last_generated := id;
		if x_dest = 1 & y_dest = 1 { #only if it's going directly north
			if arb_N_10.faulty & ~arb_W_10.faulty & ~arb_W_10.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
				assigned := aw10; #send it to the other arbiter if an10 is blocked.	
				ready := true; #mark that it's ready to receive a packet
			}
			else if arb_N_10.busy { #if the receiver is busy, 
				has_flit := false; #drop the flit to prevent deadlock
				ready := false;
			}
			else { #if it's going north and everything's clear
				require ~arb_N_10.faulty & ~arb_N_10.busy; #double check that it's clear
				assigned := an10; #send north if it needs to go to (1,1)
				ready := true;
			}
		}
		else { #same as 110-123 but for packets not going to (1,1).
			if arb_W_10.faulty & ~arb_N_10.faulty & ~arb_N_10.busy {
				assigned := an10; #send it to the other arbiter if aw10 is blocked.
				ready := true;
			}
			else if arb_W_10.busy {
				has_flit := false; #if it looks like it could cause deadlock, drop the flit.
				ready := false;
			}
			else {
				require ~arb_W_10.faulty & ~arb_N_10.busy;
				assigned := aw10; #if it's not going to (1,1), send it west by default.
				ready := true;
			}
		}
    }
	
	action send_flit(s:router,r:router,a:arbiter) = {
		require has_flit & ready;
		call intf.check(s,r,a);
	}
	
	export generate
	export send_flit
   
} #closeob

object arb_W_10 = {
	
	individual faulty : bool
	individual busy : bool
	
	type can_get_from = {void,r_pe_10,r_w_10,r_n_10} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { 							#before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
		require ~busy & ((r_PE_10.has_flit & r_PE_10.assigned = aw10) | (r_W_10.has_flit & r_W_10.assigned = aw10) | (r_N_10.has_flit & r_N_10.assigned = aw10)); 
		rand := *;
	}
	
	before move_flit { #check for simultaneous requests
		if r_PE_10.has_flit & r_PE_10.assigned = aw10 {
			if r_W_10.has_flit & r_W_10.assigned = aw10 {
				if r_N_10.has_flit & r_N_10.assigned = aw10 {
					get_from := *;
				}
				else {
					if rand {
						get_from := r_pe_10;
					}
					else {
						get_from := r_w_10;
					}
				}
			}
			else {
				get_from := r_pe_10;
			}
		}	
		else if r_W_10.has_flit & r_W_10.assigned = aw10 {
			if r_N_10.has_flit & r_N_10.assigned = aw10 {
				if rand {
					get_from := r_w_10;
				}
				else {
					get_from := r_n_10;
				}
			}
			else {
				get_from := r_w_10;
			}
		}
		else if r_N_10.has_flit & r_N_10.assigned = aw10 {
			get_from := r_n_10;
		}
	}
	
	action move_flit = { 
		call intf.send; #modify the sending relation
		if get_from = r_pe_10 { #send the packet and all its information
			r_PE_10.has_flit := false;
			r_E_00.x_dest := r_PE_10.x_dest;
			r_E_00.y_dest := r_PE_10.y_dest;
			r_E_00.id := r_PE_10.id;
			r_E_00.has_flit := true;
		}
		else if get_from = r_w_10 {
			r_W_10.has_flit := false;
			r_E_00.x_dest := r_W_10.x_dest;
			r_E_00.y_dest := r_W_10.y_dest;
			r_E_00.id := r_W_10.id;
			r_E_00.has_flit := true;
		}
		else if get_from = r_n_10 {
			r_N_10.has_flit := false;
			r_E_00.x_dest := r_N_10.x_dest;
			r_E_00.y_dest := r_N_10.y_dest;
			r_E_00.id := r_N_10.id;
			r_E_00.has_flit := true;
		}
	}
	export move_flit
} #closeob 

object arb_N_10 = {
	
	individual faulty : bool
	individual busy : bool
		
	type can_get_from = {void,r_pe_10,r_w_10,r_n_10} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { 							#before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
		require ~busy & ((r_PE_10.has_flit & r_PE_10.assigned = an10) | (r_W_10.has_flit & r_W_10.assigned = an10) | (r_N_10.has_flit & r_N_10.assigned = an10)); 
		rand := *;
	}
	
	before move_flit { #check for simultaneous requests
		if r_PE_10.has_flit & r_PE_10.assigned = an10 {
			if r_W_10.has_flit & r_W_10.assigned = an10 {
				if r_N_10.has_flit & r_N_10.assigned = an10 {
					get_from := *;
				}
				else {
					if rand {
						get_from := r_pe_10;
					}
					else {
						get_from := r_w_10;
					}
				}
			}
			else {
				get_from := r_pe_10;
			}
		}	
		else if r_W_10.has_flit & r_W_10.assigned = an10 {
			if r_N_10.has_flit & r_N_10.assigned = an10 {
				if rand {
					get_from := r_w_10;
				}
				else {
					get_from := r_n_10;
				}
			}
			else {
				get_from := r_w_10;
			}
		}
		else if r_N_10.has_flit & r_N_10.assigned = an10 {
			get_from := r_n_10;
		}
	}
	
	action move_flit = { 
		call intf.send; #modify the sending relation
		if get_from = r_pe_10 { #send the packet and all its information
			r_PE_10.has_flit := false;
			r_S_11.x_dest := r_PE_10.x_dest;
			r_S_11.y_dest := r_PE_10.y_dest;
			r_S_11.id := r_PE_10.id;
			r_S_11.has_flit := true;
		}
		else if get_from = r_w_10 {
			r_W_10.has_flit := false;
			r_S_11.x_dest := r_W_10.x_dest;
			r_S_11.y_dest := r_W_10.y_dest;
			r_S_11.id := r_W_10.id;
			r_S_11.has_flit := true;
		}
		else if get_from = r_n_10 {
			r_N_10.has_flit := false;
			r_S_11.x_dest := r_N_10.x_dest;
			r_S_11.y_dest := r_N_10.y_dest;
			r_S_11.id := r_N_10.id;
			r_S_11.has_flit := true;
		}
		
	}
	
	export move_flit
} #closeob 

object arb_PE_10 = {
	
	individual busy : bool
	
	type can_get_from = {r_w_10,r_n_10} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	
	after init { 							#before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
		require ~busy & ((r_W_10.has_flit & r_W_10.assigned = ape10) | (r_N_10.has_flit & r_N_10.assigned = ape10)); 
	}
	
	before move_flit { #check for simultaneous requests
		if r_N_10.has_flit & r_N_10.assigned = ape10 {
			if r_W_10.has_flit & r_W_10.assigned = ape10 {
				get_from := *;
			}
			else {
				get_from := r_n_10;
			}
		}
		else if r_W_10.has_flit & r_W_10.assigned = ape10 {
			get_from := r_w_10;
		}
		
	}
	
	action move_flit = { 
		call intf.send; #modify the sending relation
		if get_from = r_w_10 {
			r_W_10.has_flit := false;
		}
		else if get_from = r_n_10 {
			r_N_10.has_flit := false;
		}
	}
	
	export move_flit
} #closeob 

module r_x_10 = {
	individual has_flit : bool
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	individual ready : bool
	individual id : int #the ID of the flit that is currently here
	individual tally : int
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		tally := 0;
	}
	
	action assigner = { #check the destination to determine which arbiter to assign.
		require has_flit;
		if x_dest = 1 & y_dest = 0 {
			assigned := ape10;
			ready := true;	
		} 
		else if x_dest = 1 & y_dest = 1 { #only if it's going directly north
			if arb_N_10.faulty & ~arb_W_10.faulty & ~arb_W_10.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
				assigned := aw10; #send it to the other arbiter if an10 is blocked.	
				ready := true; #mark that it's ready to receive a packet
			}
			else if arb_N_10.busy { #if the receiver is busy, 
				has_flit := false; #drop the flit to prevent deadlock
				ready := false;
			}
			else { #if it's going north and everything's clear
				require ~arb_N_10.faulty & ~arb_N_10.busy; #double check that it's clear
				assigned := an10; #send north if it needs to go to (1,1)
				ready := true;
			}
		}
		else { #same as 110-123 but for packets not going to (1,1).
			if arb_W_10.faulty & ~arb_N_10.faulty & ~arb_N_10.busy {
				assigned := an10; #send it to the other arbiter if aw10 is blocked.
				ready := true;
			}
			else if arb_W_10.busy {
				has_flit := false;
				ready := false;
			}
			else {
				require ~arb_W_10.faulty & ~arb_N_10.busy;
				assigned := aw10; #if it's not going to (1,1), send it west by default.
				ready := true;
			}
		}	
	}
	
	action counter = {
		require has_flit & (id = flit_to_watch); #only proceed if it has a flit and the ID is the assigned ID to watch
		assert has_flit & id = flit_to_watch;
		tally := tally + 1; #only increment the counter if it's 4 or less.
#		assert tally <= 5;
	}
	
	execute counter before assigner #make sure to count the visits before sending the flit somewhere.
	
	export assigner
	export counter
	
} #closeob 
instance r_N_10 : r_x_10
instance r_W_10 : r_x_10




###########################################################
########### NODE (0,0) #################################### DONE
###########################################################

object arb_E_00 = {
	
	individual faulty : bool
	individual busy : bool
	
	type can_get_from = {void,r_pe_00,r_e_00,r_n_00} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { 							#before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
		require ~busy & (r_E_00.has_flit & r_E_00.assigned = ae00); 
		rand := *;
	}
	
	before move_flit { #check for simultaneous requests
		if r_E_00.has_flit & r_E_00.assigned = ae00 {
			get_from := r_e_00;
		}
	}
	
	action move_flit = { 
		call intf.send; #modify the sending relation
		if get_from = r_e_00 {
			r_E_00.has_flit := false;
			r_W_10.x_dest := r_E_00.x_dest;
			r_W_10.y_dest := r_E_00.y_dest;
			r_W_10.id := r_E_00.id;
			r_W_10.has_flit := true;
		}
	}
	export move_flit
} #closeob 

object r_E_00 = {
	individual has_flit : bool
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	individual ready : bool
	individual id : int #the ID of the flit that is currently here
	individual tally : int
	
	after init {
		has_flit := *; #it may already have a flit when r_PE_10 generates a flit
		tally := 0;
	}
	
	action assigner = { #check the destination to determine which arbiter to assign.
		require has_flit;
		if x_dest = 0 & y_dest = 0 {
			assigned := ape00;
			ready := true;	
		} 
		else if x_dest = 1 & y_dest = 0 { #only if it's going directly north
			if arb_E_00.faulty & ~arb_N_00.faulty & ~arb_N_00.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
				assigned := an00; #send it to the other arbiter if ae00 is blocked.	
				ready := true; #mark that it's ready to receive a packet
			}
			else if arb_N_00.busy { #if the receiver is busy, 
				has_flit := false; #drop the flit to prevent deadlock
				ready := false;
			}
			else { #if it's going north and everything's clear
				require ~arb_E_00.faulty & ~arb_E_00.busy; #double check that it's clear
				assigned := ae00; #send north if it needs to go to (1,1)
				ready := true;
			}
		}
		else { 
			if arb_N_00.faulty & ~arb_E_00.faulty & ~arb_E_00.busy {
				assigned := ae00; #send it to the other arbiter if an00 is blocked.
				ready := true;
			}
			else if arb_N_00.busy {
				has_flit := false; #if it looks like it could cause deadlock, drop the flit.
				ready := false;
			}
			else {
				require ~arb_N_00.faulty & ~arb_N_00.busy;
				assigned := an00; #if it's not going to (1,1), send it west by default.
				ready := true;
			}
		}
	}
	
	action counter = {
		require has_flit & (id = flit_to_watch); #only proceed if it has a flit and the ID is the assigned ID to watch
		assert has_flit & id = flit_to_watch;
		tally := tally + 1; #only increment the counter if it's 4 or less.
#		assert tally <= 5;
	}
	
	execute counter before assigner #make sure to count the visits before sending the flit somewhere.
	
	export assigner
	export counter
	
} #closeob 





###########################################################
########### NODE (1,1) #################################### DONE
###########################################################


object arb_S_11 = {
	
	individual faulty : bool
	individual busy : bool
	
	type can_get_from = {void,r_pe_11,r_w_11,r_s_11} #possibilities of routers that can have a packet to send
	individual get_from : can_get_from #where the arbiter decides to get from
	individual rand : bool
	
	after init { 							#before the arbiter can get a flit, make sure that it's not blocked, that a flit exists, and that it's assigned here.
		require ~busy & ((r_PE_11.has_flit & r_PE_11.assigned = as11) | (r_W_11.has_flit & r_W_11.assigned = as11) | (r_S_11.has_flit & r_S_11.assigned = as11)); 
		rand := *;
	}
	
	before move_flit { #check for simultaneous requests
		if r_PE_11.has_flit & r_PE_11.assigned = as11 {
			if r_W_11.has_flit & r_W_11.assigned = as11 {
				if r_S_11.has_flit & r_S_11.assigned = as11 {
					get_from := *;
				}
				else {
					if rand {
						get_from := r_pe_11;
					}
					else {
						get_from := r_w_11;
					}
				}
			}
			else {
				get_from := r_pe_11;
			}
		}	
		else if r_W_11.has_flit & r_W_11.assigned = as11 {
			if r_S_11.has_flit & r_S_11.assigned = as11 {
				if rand {
					get_from := r_w_11;
				}
				else {
					get_from := r_s_11;
				}
			}
			else {
				get_from := r_w_11;
			}
		}
		else if r_S_11.has_flit & r_S_11.assigned = as11 {
			get_from := r_s_11;
		}
	}
	
	action move_flit = { 
		call intf.send; #modify the sending relation
		if get_from = r_pe_11 { #send the packet and all its information
			r_PE_11.has_flit := false;
			r_N_10.x_dest := r_PE_11.x_dest;
			r_N_10.y_dest := r_PE_11.y_dest;
			r_N_10.id := r_PE_11.id;
			r_N_10.has_flit := true;
		}
		else if get_from = r_w_11 {
			r_W_11.has_flit := false;
			r_N_10.x_dest := r_W_11.x_dest;
			r_N_10.y_dest := r_W_11.y_dest;
			r_N_10.id := r_W_11.id;
			r_N_10.has_flit := true;
		}
		else if get_from = r_s_11 {
			r_S_11.has_flit := false;
			r_N_10.x_dest := r_S_11.x_dest;
			r_N_10.y_dest := r_S_11.y_dest;
			r_N_10.id := r_S_11.id;
			r_N_10.has_flit := true;
		}
	}
	export move_flit
} #closeob 

object r_S_11 = {
	individual has_flit : bool
	individual x_dest : coord
	individual y_dest : coord
	individual assigned : arbiter
	individual ready : bool
	individual id : int #the ID of the flit that is currently here
	individual tally : int
	
	after init {
		has_flit := false; #it may already have a flit when r_PE_10 generates a flit
		tally := 0;
	}
	
	action assigner = { #check the destination to determine which arbiter to assign.
		require has_flit;
		require tally < 5;
		if x_dest = 1 & y_dest = 1 {
			assigned := ape11;
			ready := true;
		} 
		else if x_dest = 0 & y_dest = 1 { #only if it's going directly north
			if arb_W_11.faulty & ~arb_S_11.faulty & ~arb_S_11.busy { #if the link to (1,1) is faulty #the receiving arbiter cannot be blocked or faulty either
				assigned := aw11; #send it to the other arbiter if ae00 is blocked.	
				ready := true; #mark that it's ready to receive a packet
			}
			else if arb_S_11.busy { #if the receiver is busy, 
				has_flit := false; #drop the flit to prevent deadlock
				ready := false;
			}
			else { #if it's going south and everything's clear
				require ~arb_W_11.faulty & ~arb_W_11.busy; #double check that it's clear
				assigned := as11; #send north if it needs to go to (1,1)
				ready := true;
			}
		}
		else { 
			if arb_S_11.faulty & ~arb_W_11.faulty & ~arb_W_11.busy {
				assigned := as11; #send it to the other arbiter if an00 is blocked.
				ready := true;
			}
			else if arb_S_11.busy {
				has_flit := false; #if it looks like it could cause deadlock, drop the flit.
				ready := false;
			}
			else {
				require ~arb_W_11.faulty & ~arb_W_11.busy;
				assigned := aw11; #if it's not going to (1,1), send it west by default.
				ready := true;
			}
		}
	}
	
	action counter = {
		require has_flit & (id = flit_to_watch); #only proceed if it has a flit and the ID is the assigned ID to watch
		assert has_flit & id = flit_to_watch;
		tally := tally + 1; #only increment the counter if it's 4 or less.
#		assert tally <= 5;
	}
	
	execute counter before assigner #make sure to count the visits before sending the flit somewhere.
	
	export assigner
	export counter
	
} #closeob 



####################
#                  #
#  THE INVARIANTS  #
#                  #
####################

#None needed by ivy_check. I'll see if I can come up with some.


#CHECKING FOR POSSIBILITIES OF DEADLOCK
#Because there are only a few routers, this is not complete yet.
invariant ~(r_W_10.has_flit & (r_W_10.assigned = an10) & r_S_11.has_flit & (r_W_10.assigned = aw11)) #preventing deadlock???
	#this will work much better once the model has been expanded to include the other nodes.


#CHECKING FOR POSSIBILITIES OF LIVELOCK
# invariant r_S_11.tally <= 5
# invariant r_E_00.tally <= 5
# invariant r_N_10.tally <= 5
# invariant r_W_10.tally <= 5 #when you change the 5 to a 4 on any of
# these, it fails ivy_check... that seems promising.
# invariant ~(r_S_11.tally > 5) & ~(r_N_10.tally > 5)


