#lang ivy1.7

#Just one enumerated type (top/bottom) like left/right in the ping pong example.
type loc = {top,bottom} #whether 
var flit_is : loc

object rar = {
	
	#the sending portion of the router
	#already has a flit that came from upstream
	object r_send = {
		
		individual has_flit : bool #whether or not there is a flit here
		
		after init {
			has_flit := true; #start with a flit
			flit_is := top ;#Model starts with flit on the top (in the sender)
			assert has_flit; #make sure it knows there is a flit
		}
		
		before send {
			require has_flit; #required to have a flit before one can be sent
			assert flit_is = top; #make sure the starting location is top
		}
		
		action send = {
			call arbiter.check; #like telling the arbiter it has a packet
			has_flit := false; #upon sending, does not have a flit
		}
		
		after send {
			assert ~has_flit;
		#	RESET THE FLIT - OPTIONAL
		#	has_flit := true;
		#	flit_is := top;
		}
		
		conjecture has_flit -> flit_is = top #location and status must correspond.
		
	} #end r_send 
	
	object arbiter = {

		action check = {
			require ~r_recv.has_flit; #only move on if the downstream router is available
			if r_send.has_flit {
				assert ~r_recv.has_flit; #make sure the downstream router is available
				assert r_send.has_flit; #make sure the upstream router has the flit
				call r_recv.get_flit; #call the downstream router to get the flit
			}; #endif
		} 
		
	} #end arbiter
	
	object r_recv = {
		
		individual has_flit : bool #whether or not there is a flit here
		
		after init {
			has_flit := false; #start without a flit
			assert ~has_flit; #make sure it knows there is no flit
		}
		
		before get_flit {
			require ~has_flit; #make sure there is no flit here before getting one
			assert flit_is = top; #make sure the flit's status is top
		}
		
		action get_flit = {
			has_flit := true; #get the flit
			flit_is := bottom; #change the flit's status
		}
		
		after get_flit {
			assert has_flit; #make sure it got the flit
			assert flit_is = bottom; #make sure the flit's status is correct
		#	RESET THE FLIT - OPTIONAL
		#	has_flit := false;
		#	flit_is := top;
		}
		
		conjecture has_flit -> flit_is = bottom #location and status must correspond.
		
	} #end r_recv

	#Exported actions. Note: exporting check fails 4 checks right now. Working on that...
#	export arbiter.check #can be called by the environment (like the arbiter checking for packets)
	export r_send.send #can be called by the environment (like the router saying it's ready to send)

	#Both cannot have a flit at the same time:
	invariant ~(r_recv.has_flit & r_send.has_flit)
	
	#The location and status of packets must match.
	invariant ~(r_recv.has_flit & flit_is = top) 
	invariant ~(r_send.has_flit & flit_is = bottom)
	invariant (r_recv.has_flit -> flit_is = bottom) 
	invariant (r_send.has_flit -> flit_is = top)
	
} #end r_a_r
#and one more line to make it an even 100.